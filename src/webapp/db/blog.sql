/*
 Navicat Premium Data Transfer

 Source Server         : 阿里云
 Source Server Type    : MySQL
 Source Server Version : 80015
 Source Host           : 47.101.223.154:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80015
 File Encoding         : 65001

 Date: 02/06/2019 13:35:28
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_no` int(1) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '序号',
  `user_no` int(1) UNSIGNED NOT NULL COMMENT '作者序号',
  `article_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '标题',
  `article_summary` varchar(500) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '概要',
  `article_img` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '缩略图',
  `article_release_time` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) COMMENT '更新时间就是发布时间',
  `article_corpus_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '所属文集',
  `article_type` bit(2) NOT NULL DEFAULT b'0' COMMENT '文章类型',
  `article_commentable` bit(1) NOT NULL DEFAULT b'1' COMMENT '可否评论',
  `article_private` bit(1) NOT NULL DEFAULT b'0' COMMENT '是否私密文章',
  `article_read_num` int(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '阅读数',
  `article_like_num` int(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '喜欢数',
  `article_comment_num` int(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '评论数',
  `article_collect_num` int(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '被收藏数',
  `article_word_num` int(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '字数',
  PRIMARY KEY (`article_no`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (20, 1, 'docker----学习简记', '安装容器\n\n- yum install docker-io -y\n- docker -v\n- service docker start\n- chkconfig docker on\n\n配置容器\n\n- echo \"OPTIONS=\'--registry-mirror=https://mirror.ccs.tencentyun.com\'\" >> /etc/sysconfig/dock设置阿里云镜像仓库\n安装容器- yum install docker-io -y- docker -v- service docker start- chkconfig docker on配置...', 'https://upload-images.jianshu.io/upload_images/9031347-1b703e02f9c82198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240', '2019-06-01 07:30:09.869379', 'docker', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (21, 1, '（转）CAP和BASE理论', '2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch...', '', '2019-06-01 07:38:04.454732', 'j2ee', b'01', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (22, 1, 'J2ee----详解Servlet', 'Servlet是Server+applet的缩写，即服务器应用小程序。它其实就是一套规范，按照这套规范写的代码可以直接在Java服务器上面运行。Servlet（tomcat8.5.34）的', 'https://upload-images.jianshu.io/upload_images/9031347-497ba8bf914b5a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240', '2019-06-01 07:35:12.069452', 'j2ee', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (23, 1, 'Java(转)----How-to-start-working-with-Lambda-Expressions-in-Java', 'Before Lambda expressions support was added by JDK 8, I’d only used examples of them in...', '', '2019-06-01 07:37:56.736687', 'java', b'01', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (24, 1, 'java----从计算机存储形式分析java中基本类型', '以上基本类型的默认值都是各种不同形式的0，需要注意的是：在java中没有针对boolean对象的专门字节码表示，boolean = false表示的就是ICONST_0，也...', 'https://upload-images.jianshu.io/upload_images/9031347-b1a000a1542e35ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240', '2019-06-01 07:40:01.081081', 'java', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (25, 1, 'Java----NioSocket的简单使用', '书上举例：把网络请求比喻成发电报，我们将电报内容以摩尔斯电码的形式发出去，要先将内容翻译成摩尔斯电码，即编码。接受者接受到“滴滴滴”的信息，需要解码成人类能看得懂的内容。在网...', 'https://upload-images.jianshu.io/upload_images/9031347-276b3cb73a833b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240', '2019-06-01 07:46:01.478044', 'java', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (26, 1, 'Java----Pattern与Matcher使用实例', 'Pattern的构造器被保护了起来，创建Pattern对象要靠使用compile方法编译正则表达式的返回Pattern的对象实例来实现！\r\n获取编译的正则表达式，而flags()...', '', '2019-06-02 04:28:26.689202', 'java', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (27, 1, 'ACM----相关余数定理及相关题目', '重刷HDU，看到以前一个关于余数的题目，觉得相关余数的一些性质定理是时候总结下了！\r\n\r\n# 1. 概念：同余\r\n> 若a , b除以c的余数相等，则a与b相对于除数c是同余的，即a≡ b(mod c)！', '', '2019-06-02 04:29:59.313983', 'ACM', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (28, 1, 'ACM----已知前序遍历序列和后序遍历序列求后序遍历序列', '很是激动，离开ACM一年后还能找回当时ac时激动的感觉。虽然挺简单的一题，在苦思冥想之后想到左右子树分治采用递归解法。一次Compilation Error后就ac了。就算是重启刷题的开门红吧。', '', '2019-06-02 04:32:43.659766', 'ACM', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (29, 1, 'Linux（转）----centos关于线程命令简记', '感觉写的很好的两篇文章:All You Need To Know About Processes in Linux 和Processes in Linux/Unix,本来想像文件权限那篇文章那样全文翻译过来，这样既能锻炼英语，又能加深linux相关知识。可是作业要紧，做完作业，找时间吧！', '', '2019-06-02 04:35:53.609206', 'linux', b'01', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (30, 1, 'Linux----较新版linux系统vi不能强制保存只读文件错误', '今天写linux的试验报告四，有一道题要修改系统应道程序的配置文件grub.conf（有些系统是menu.lst）让开机菜单的等待时间为10秒并在标题的后面加上自己姓名的拼音！可是在我找到这个配置文件的时候修改完，', '', '2019-06-02 04:36:03.808623', 'linux', b'01', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (31, 1, 'Linux----用户管理相关知识简介', '被加密的密码，如果有的用户在此字段中是x，表示这个用户不能登录系统，也可以看作是虚拟用户，不过虚拟用户和真实用户都是相对的，系统管理员随时可以对任何用户 操作；', '', '2019-06-02 04:37:01.236502', 'linux', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (32, 1, 'Linux----命令行简记', '该命令做了下面几件事：1. 在 /etc/passwd 文件中增添了一行记录；2. 在 /home 目录下创建新用户的主目录，并将 /etc/skel 目录中的文件拷贝到该目录中去；3. 但是使用了该命令后，新建的用户暂时还无法登录，因为还没有为该用户设置口令，需要再', '', '2019-06-02 04:38:16.178841', 'linux', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (33, 1, 'Mybatis----完成HelloWorld程序', '每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。', '', '2019-06-02 04:39:44.934434', 'mybatis', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (34, 1, '计算机组成原理(转)----何为电脑和系统的32位和64位属性', '64 位 CPU 是指 CPU 内部的通用寄存器的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算。那么 32 位 CPU 同理。\r\n一个 CPU，联系外部的数据总线与地址总线，', '', '2019-06-02 04:41:08.512021', '操作系统', b'00', b'1', b'0', 0, 0, 0, 0, 0);
INSERT INTO `article` VALUES (35, 1, '设计模式----策略模式.md', '很久以前就开始看设计模式了，后面停了一段时间然后借到了一本《Head First 设计模式》，head first即面向初学者之意，语言风趣，例子简单，讲解设计模式循序渐进，许多规范会通过很多现实中的例子来讲解其意义所在！虽有些长篇大论，', '', '2019-06-02 04:42:31.125197', '设计模式', b'00', b'1', b'0', 0, 0, 0, 0, 0);

-- ----------------------------
-- Table structure for article_content
-- ----------------------------
DROP TABLE IF EXISTS `article_content`;
CREATE TABLE `article_content`  (
  `article_no` int(15) UNSIGNED NOT NULL COMMENT '对应那篇文章',
  `content` text CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '内容',
  PRIMARY KEY (`article_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_content
-- ----------------------------
INSERT INTO `article_content` VALUES (20, '# 安装容器\r\n- yum install docker-io -y\r\n- docker -v\r\n- service docker start\r\n- chkconfig docker on\r\n\r\n# 配置容器\r\n-  echo \"OPTIONS=\'--registry-mirror=https://mirror.ccs.tencentyun.com\'\" >> /etc/sysconfig/dock设置阿里云镜像仓库\r\n- systemctl daemon-reload 重启守护线程\r\n- service docker restart 重启服务\r\n- docker pull centos 下载官方centos镜像到本地\r\n-   下载好的镜像就会下载到本地\r\n- docker run --name==hsw -it centos /bin/bash 生成一个 centos 镜像为模板的容器并使用 bash shell\r\n\r\n>  这个时候可以看到命令行的前端已经变成了 [root@(一串 hash Id)] 的形式, 这说明我们已经成功进入了 CentOS 容器。\r\n\r\n# 登录容器\r\n- 在容器内执行任意命令, 不会影响到宿主机, 如下\r\n  mkdir -p /data/simple_docker\r\n\r\n- 可以看到 /data 目录下已经创建成功了 simple_docker 文件夹\r\n  ls /data\r\n\r\n  > 而退出容器\r\n  > exit就看不到了！\r\n\r\n# 保存容器\r\n- 然后执行如下命令，保存镜像：\r\n  docker commit -m=\"备注\" 你的CONTAINER_ID 你的IMAGE\r\n\r\n- 重新启动刚刚停止的容器\r\n  docker start -i hsw别名\r\n\r\n# 删除容器 \r\n- ctrl+P 和 ctrl+Q退出容器，但容器在后台运行\r\n  重新回去 使用 docker attach containerID（使用docker ps -a看到）\r\n\r\n- 停止守护容器\r\n  docker stop 容器名 （docker start 容器ID开启）\r\n- docker kill 容器名 （这个就开启不了了）\r\n\r\n# 其他\r\n- docker top\r\n\r\n- docker logs\r\n\r\n- docker exec \r\n\r\n  > 更多命令使用帮助手册\r\n\r\n# 设置端口映射\r\n\r\n如果需要在容器中部署网站，这就需要访问容器的端口，所以就要映射系统端口和容器端口！\r\n\r\n- run时 使用 大写的 —P将会将容器所有的端口设置映射！ \r\n\r\n- 而小写的p可以指定映射端口 ，四种格式：\r\n\r\n  - containerPort\r\n\r\n    docker run -p 80 ...\r\n\r\n  - hostPort:containerPort\r\n\r\n    docker run -p 8080:80...\r\n\r\n  - ip::containerPort\r\n\r\n    docker run -p 0.0.0.0:80...\r\n\r\n  - ip::hostPort : containerPort\r\n\r\n    docker run -p 0.0.0.0:\r\n\r\n# 推送私有库\r\n\r\nstep1——注册[dockerhub](https://cloud.docker.com/)\r\n\r\nstep2——登陆Hub：docker login\r\n\r\nstep3——打标签：docker tag centos dockhapi/one:v1(注意dockhapi/one分别对应于用户名和仓库名，打标签相当于作为一次版本，或者说是存档！)\r\n\r\nstep4——tag：推送：docker push dockhapi/one:v1\r\n![](https://upload-images.jianshu.io/upload_images/9031347-1b703e02f9c82198.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n\r\n');
INSERT INTO `article_content` VALUES (21, '# 1. CAP理论\r\n2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。\r\n\r\nCAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。\r\n\r\n## 1.1 一致性（Consistency）\r\n一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。\r\n\r\n## 1.2 可用性（Availability）\r\n可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。\r\n\r\n\r\n## 1.3 分区容错性（Partition tolerance）\r\n分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。\r\n\r\n# 2. CAP权衡\r\n通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？\r\n\r\n对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。\r\n\r\n对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。\r\n\r\n孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。\r\n\r\n# 3. BASE理论\r\neBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。\r\n\r\nBASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。\r\n\r\n## 3.1 基本可用（Basically Available）\r\n基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。\r\n电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。\r\n\r\n## 3.2 软状态（ Soft State）\r\n软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。\r\n\r\n## 3.3 最终一致性（ Eventual Consistency）\r\n最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。\r\n# 4. ACID和BASE的区别与联系\r\nACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。\r\n\r\nACID和BASE代表了两种截然相反的设计哲学\r\n\r\n在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。\r\n');
INSERT INTO `article_content` VALUES (22, '> 参考 《看透Spring MVC 源代码分析与实践》\r\n对于想学习javaweb的我来说，这本书上全书干货啊！墙裂推荐！！！\r\n以下很多内容摘抄自此书！\r\n\r\n# Servlet\r\nServlet是Server+applet的缩写，即服务器应用小程序。它其实就是一套规范，按照这套规范写的代码可以直接在Java服务器上面运行。\r\n****\r\n# Servlet（tomcat8.5.34）的结构\r\n既然是规范，最终套的就是接口\r\n平常web程序中继承的HttpServlet类继承自GerericServlet（可以叫做通用servlet类），GenericServlet实现了两个接口。\r\n![类图](https://upload-images.jianshu.io/upload_images/9031347-497ba8bf914b5a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n### Servlet接口\r\nservlet子类的一个规范\r\n```java\r\npackage javax.servlet;\r\nimport java.io.IOException;\r\npublic interface Servlet {\r\n    void init(ServletConfig var1) throws ServletException;\r\n\r\n    ServletConfig getServletConfig();\r\n\r\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\r\n\r\n    String getServletInfo();\r\n\r\n    void destroy();\r\n}\r\n```\r\n####方法解析：\r\n- **init**\r\ninit方法被容器（即tomcat）调用（当我们在web.xml中设置load-on-startup设置成负数或不设置时会在Servlet第一次调用时才会被调用。设置成0或正数时才会在容器启动时被调用，并且正数越大优先级越高！），只会被调用一次。\r\n- **getServletConfig**\r\ngetServletConfig方法用于获取ServletConfig。从init方法的参数可以看到，是当容器调用init时将ServletConfig传进来的。\r\n- **service**\r\n用于处理一个请求（Tomcat处理请求的流程待我研究下。）\r\n- **getServletInfo**\r\ngetServletInfo可以获得Servlet的相关信息，如作者、版权等，这个方法自己实现吗，默认返回空字符串！\r\n- **destory**\r\ndestory方法用于servket的销毁（一般在tomcat容器关闭时）释放一些资源，也只会调用一次！\r\n### ServletConfig接口\r\nServlet的init方法会接收一个容器传入的ServletConfig类型的参数，顾名思义就是servelt的配置参数，我们在web.xml中配置的**init-param**标签中的参数就是保存在ServletConfig中的！比如SpringMVC的配置文件的位置contextConfigLocation。比如：\r\n```html\r\n    <servlet>\r\n        <servlet-name>DispatcherServlet</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <!--contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等）-->\r\n        <!--如果不配置，则默认加载/WEB-INFO/servlet下名称为-servlet.xml(springmvc-servlet.xml)-->\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <!--放在src文件夹下，所以就是classpath：...-->\r\n            <param-value>/WEB-INF/springmvc.xml</param-value>\r\n        </init-param>\r\n        <!--设置为容器启动时调用Servlet的init方法！-->\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n```\r\nServletConfig接口代码：\r\n```java\r\npackage javax.servlet;\r\nimport java.util.Enumeration;\r\npublic interface ServletConfig {\r\n    String getServletName();\r\n\r\n    ServletContext getServletContext();\r\n\r\n    String getInitParameter(String var1);\r\n\r\n    Enumeration<String> getInitParameterNames();\r\n}\r\n```\r\n####方法解析：\r\n- **getServletName**\r\n很简单即获得Servlet的名称！也就是上述配置中<servlet-name>标签内的内容！\r\n- **getServletContext**\r\n这个方法非常重要，用来获得ServletContext（Servlet运行上下文环境）即就是我们这个应用的本身！ServletContext中配置的参数可以被所有servlet所共享！我们在开发web程序时可以将参数保存在session，也可以保存在application中，后者就是保存在ServletContext中。\r\n> 可以这么理解，ServletConfig是servlet级别的，而ServletContext是application级别的（当然ServletContext不只是保存配置参数的）。还有更高一层的站点即是Tomcat中的Host级别的，在ServletContext接口中有一个ServletContext getContext（String uriPath）方法获得同意tomcat下的其他web应用的ServletContext。但这样不安全，一般返回null，有需求可以进行相关设置！\r\n- **getInitParameter**\r\n以参数为键获得web.xml中标签<init-param>配置的参数\r\n- **getInitParameterNames**\r\n获得所有配置了的参数的集合\r\n\r\n##### 以上所述的两个接口与下面的GenericServlet父类都能在： tomcat目录\\lib\\servlet-api.jar\\javax\\servlet\\ 目录下找到：\r\n![](https://upload-images.jianshu.io/upload_images/9031347-58c8f86f803bf429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n> 目录不符是因为压缩软件不默认能打开jar文件，然后我将其复制到桌面然后添加进压缩包，打开压缩包，在里面继续双击jar包就可以进去了！\r\n****\r\n\r\n# GenericServlet类\r\n### 类源代码\r\n```java\r\npackage javax.servlet;\r\nimport java.io.IOException;\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\npublic abstract class GenericServlet implements Servlet, ServletConfig, Serializable {\r\n    private static final long serialVersionUID = 1L;\r\n    private transient ServletConfig config;\r\n    public GenericServlet() {\r\n    }\r\n    public void destroy() {\r\n    }\r\n    public String getInitParameter(String name) {\r\n        return this.getServletConfig().getInitParameter(name);\r\n    }\r\n    public Enumeration<String> getInitParameterNames() {\r\n        return this.getServletConfig().getInitParameterNames();\r\n    }\r\n    public ServletConfig getServletConfig() {\r\n        return this.config;\r\n    }\r\n    public ServletContext getServletContext() {\r\n        return this.getServletConfig().getServletContext();\r\n    }\r\n    public String getServletInfo() {\r\n        return \"\";\r\n    }\r\n    public void init(ServletConfig config) throws ServletException {\r\n        this.config = config;\r\n        this.init();\r\n    }\r\n    public void init() throws ServletException {\r\n    }\r\n    public void log(String msg) {\r\n        this.getServletContext().log(this.getServletName() + \": \" + msg);\r\n    }\r\n    public void log(String message, Throwable t) {\r\n        this.getServletContext().log(this.getServletName() + \": \" + message, t);\r\n    }\r\n    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\r\n    public String getServletName() {\r\n        return this.config.getServletName();\r\n    }\r\n}\r\n```\r\nGenericServlet作为Servlet的默认子类，GenericSerclet主要实现了三件事：\r\n1. **实现了ServletConfig**\r\n可以直接使用ServletConfig的方法而不用调用Config属性。比如：当我们要获得ServletContext时，可以直接使用getServletContext()方法，而不用getServletConfig().getServletContext()。\r\n2. **定义了init无参初始化方法**\r\ninit()是个模板方法，两个作用：这么做可以在子类中只重写init（）方法实现自己的逻辑；然后就是这样子做我们避免重写init(ServletConfig config)方法忘记调用父类init方法（```this.init(config)```）而没有将config赋给GernericServlet的config属性！\r\n> init方法：\r\n```java\r\ninit(){}\r\ninit(ServletConfig config){\r\n        this.config = config;\r\n        init();\r\n}\r\n```\r\n3. **提供了两个log方法**\r\n一个记录日志，一个记录异常，具体通过给ServletContext日志实现的！\r\n> 书上说一般我们都有自己的方法，这个用的不是很多\r\nGenericServlet与具体协议无关\r\n****\r\n# HttpServlet类\r\n####源码：\r\n```java\r\npublic abstract class HttpServlet extends GenericServlet {\r\n    private static final long serialVersionUID = 1L;\r\n    private static final String METHOD_DELETE = \"DELETE\";\r\n    private static final String METHOD_HEAD = \"HEAD\";\r\n    private static final String METHOD_GET = \"GET\";\r\n    private static final String METHOD_OPTIONS = \"OPTIONS\";\r\n    private static final String METHOD_POST = \"POST\";\r\n    private static final String METHOD_PUT = \"PUT\";\r\n    private static final String METHOD_TRACE = \"TRACE\";\r\n    private static final String HEADER_IFMODSINCE = \"If-Modified-Since\";\r\n    private static final String HEADER_LASTMOD = \"Last-Modified\";\r\n    private static final String LSTRING_FILE = \"javax.servlet.http.LocalStrings\";\r\n    private static ResourceBundle lStrings = ResourceBundle.getBundle(\"javax.servlet.http.LocalStrings\");\r\n\r\n    public HttpServlet() {\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String protocol = req.getProtocol();\r\n        String msg = lStrings.getString(\"http.method_get_not_supported\");\r\n        if (protocol.endsWith(\"1.1\")) {\r\n            resp.sendError(405, msg);\r\n        } else {\r\n            resp.sendError(400, msg);\r\n        }\r\n\r\n    }\r\n\r\n    protected long getLastModified(HttpServletRequest req) {\r\n        return -1L;\r\n    }\r\n\r\n    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        NoBodyResponse response = new NoBodyResponse(resp);\r\n        this.doGet(req, response);\r\n        response.setContentLength();\r\n    }\r\n\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String protocol = req.getProtocol();\r\n        String msg = lStrings.getString(\"http.method_post_not_supported\");\r\n        if (protocol.endsWith(\"1.1\")) {\r\n            resp.sendError(405, msg);\r\n        } else {\r\n            resp.sendError(400, msg);\r\n        }\r\n\r\n    }\r\n\r\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String protocol = req.getProtocol();\r\n        String msg = lStrings.getString(\"http.method_put_not_supported\");\r\n        if (protocol.endsWith(\"1.1\")) {\r\n            resp.sendError(405, msg);\r\n        } else {\r\n            resp.sendError(400, msg);\r\n        }\r\n\r\n    }\r\n\r\n    protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String protocol = req.getProtocol();\r\n        String msg = lStrings.getString(\"http.method_delete_not_supported\");\r\n        if (protocol.endsWith(\"1.1\")) {\r\n            resp.sendError(405, msg);\r\n        } else {\r\n            resp.sendError(400, msg);\r\n        }\r\n\r\n    }\r\n\r\n    private static Method[] getAllDeclaredMethods(Class<?> c) {\r\n        if (c.equals(HttpServlet.class)) {\r\n            return null;\r\n        } else {\r\n            Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass());\r\n            Method[] thisMethods = c.getDeclaredMethods();\r\n            if (parentMethods != null && parentMethods.length > 0) {\r\n                Method[] allMethods = new Method[parentMethods.length + thisMethods.length];\r\n                System.arraycopy(parentMethods, 0, allMethods, 0, parentMethods.length);\r\n                System.arraycopy(thisMethods, 0, allMethods, parentMethods.length, thisMethods.length);\r\n                thisMethods = allMethods;\r\n            }\r\n\r\n            return thisMethods;\r\n        }\r\n    }\r\n\r\n    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        Method[] methods = getAllDeclaredMethods(this.getClass());\r\n        boolean ALLOW_GET = false;\r\n        boolean ALLOW_HEAD = false;\r\n        boolean ALLOW_POST = false;\r\n        boolean ALLOW_PUT = false;\r\n        boolean ALLOW_DELETE = false;\r\n        boolean ALLOW_TRACE = true;\r\n        boolean ALLOW_OPTIONS = true;\r\n\r\n        for(int i = 0; i < methods.length; ++i) {\r\n            Method m = methods[i];\r\n            if (m.getName().equals(\"doGet\")) {\r\n                ALLOW_GET = true;\r\n                ALLOW_HEAD = true;\r\n            }\r\n\r\n            if (m.getName().equals(\"doPost\")) {\r\n                ALLOW_POST = true;\r\n            }\r\n\r\n            if (m.getName().equals(\"doPut\")) {\r\n                ALLOW_PUT = true;\r\n            }\r\n\r\n            if (m.getName().equals(\"doDelete\")) {\r\n                ALLOW_DELETE = true;\r\n            }\r\n        }\r\n\r\n        String allow = null;\r\n        if (ALLOW_GET) {\r\n            allow = \"GET\";\r\n        }\r\n\r\n        if (ALLOW_HEAD) {\r\n            if (allow == null) {\r\n                allow = \"HEAD\";\r\n            } else {\r\n                allow = allow + \", HEAD\";\r\n            }\r\n        }\r\n\r\n        if (ALLOW_POST) {\r\n            if (allow == null) {\r\n                allow = \"POST\";\r\n            } else {\r\n                allow = allow + \", POST\";\r\n            }\r\n        }\r\n\r\n        if (ALLOW_PUT) {\r\n            if (allow == null) {\r\n                allow = \"PUT\";\r\n            } else {\r\n                allow = allow + \", PUT\";\r\n            }\r\n        }\r\n\r\n        if (ALLOW_DELETE) {\r\n            if (allow == null) {\r\n                allow = \"DELETE\";\r\n            } else {\r\n                allow = allow + \", DELETE\";\r\n            }\r\n        }\r\n\r\n        if (ALLOW_TRACE) {\r\n            if (allow == null) {\r\n                allow = \"TRACE\";\r\n            } else {\r\n                allow = allow + \", TRACE\";\r\n            }\r\n        }\r\n\r\n        if (ALLOW_OPTIONS) {\r\n            if (allow == null) {\r\n                allow = \"OPTIONS\";\r\n            } else {\r\n                allow = allow + \", OPTIONS\";\r\n            }\r\n        }\r\n\r\n        resp.setHeader(\"Allow\", allow);\r\n    }\r\n\r\n    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String CRLF = \"\\r\\n\";\r\n        StringBuilder buffer = (new StringBuilder(\"TRACE \")).append(req.getRequestURI()).append(\" \").append(req.getProtocol());\r\n        Enumeration reqHeaderEnum = req.getHeaderNames();\r\n\r\n        while(reqHeaderEnum.hasMoreElements()) {\r\n            String headerName = (String)reqHeaderEnum.nextElement();\r\n            buffer.append(CRLF).append(headerName).append(\": \").append(req.getHeader(headerName));\r\n        }\r\n\r\n        buffer.append(CRLF);\r\n        int responseLength = buffer.length();\r\n        resp.setContentType(\"message/http\");\r\n        resp.setContentLength(responseLength);\r\n        ServletOutputStream out = resp.getOutputStream();\r\n        out.print(buffer.toString());\r\n        out.close();\r\n    }\r\n\r\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        String method = req.getMethod();\r\n        long lastModified;\r\n        if (method.equals(\"GET\")) {\r\n            lastModified = this.getLastModified(req);\r\n            if (lastModified == -1L) {\r\n                this.doGet(req, resp);\r\n            } else {\r\n                long ifModifiedSince;\r\n                try {\r\n                    ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\r\n                } catch (IllegalArgumentException var9) {\r\n                    ifModifiedSince = -1L;\r\n                }\r\n\r\n                if (ifModifiedSince < lastModified / 1000L * 1000L) {\r\n                    this.maybeSetLastModified(resp, lastModified);\r\n                    this.doGet(req, resp);\r\n                } else {\r\n                    resp.setStatus(304);\r\n                }\r\n            }\r\n        } else if (method.equals(\"HEAD\")) {\r\n            lastModified = this.getLastModified(req);\r\n            this.maybeSetLastModified(resp, lastModified);\r\n            this.doHead(req, resp);\r\n        } else if (method.equals(\"POST\")) {\r\n            this.doPost(req, resp);\r\n        } else if (method.equals(\"PUT\")) {\r\n            this.doPut(req, resp);\r\n        } else if (method.equals(\"DELETE\")) {\r\n            this.doDelete(req, resp);\r\n        } else if (method.equals(\"OPTIONS\")) {\r\n            this.doOptions(req, resp);\r\n        } else if (method.equals(\"TRACE\")) {\r\n            this.doTrace(req, resp);\r\n        } else {\r\n            String errMsg = lStrings.getString(\"http.method_not_implemented\");\r\n            Object[] errArgs = new Object[]{method};\r\n            errMsg = MessageFormat.format(errMsg, errArgs);\r\n            resp.sendError(501, errMsg);\r\n        }\r\n\r\n    }\r\n\r\n    private void maybeSetLastModified(HttpServletResponse resp, long lastModified) {\r\n        if (!resp.containsHeader(\"Last-Modified\")) {\r\n            if (lastModified >= 0L) {\r\n                resp.setDateHeader(\"Last-Modified\", lastModified);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\r\n        HttpServletRequest request;\r\n        HttpServletResponse response;\r\n        try {\r\n            request = (HttpServletRequest)req;\r\n            response = (HttpServletResponse)res;\r\n        } catch (ClassCastException var6) {\r\n            throw new ServletException(\"non-HTTP request or response\");\r\n        }\r\n\r\n        this.service(request, response);\r\n    }\r\n}\r\n\r\n```\r\n### 类解析\r\nHttpServlet是用HTTP协议实现的Servlet基类，写Servlet时直接继承它就行了，不用重头实现Servlet接口。\r\n**《看透Spring MVC 源代码分析与实践》**要研究的SpringMVC中负责请求转发的DispatcherServlet就是直接继承HttpServlet的！\r\n### 方法解析\r\nHttp主要作用就是处理请求了，所以其主要重写了service方法，上述代码中有两个service方法，下面那个功能就是将ServletRequest和ServletResponse转化为HttpServletRequest和HttpServletResponse，然后传给另一个也就是上面那个service方法根据Http请求方法交给不同的处理方法处理！\r\n\r\n处理方法：\r\n- doPost\r\n- doGet\r\n- doPut\r\n- doDelete\r\ndoPost、doGet、 doPut、doDelete都是模板方法，如果子类没有实现则抛出异常；而且在调用doGet方法时还对其是否果其进行检查，没有过期则直接返回304状态码使用缓存；\r\n- doOptions\r\n- doTrace\r\n以上两个一般正常情况不实用，主要做些调试工作！\r\n- doHead\r\n调用了doGet方法，返回有个空body的response；\r\n\r\n****\r\n\r\n\r\n美好的周末开始了，写完这篇博客就去看美剧了，天气凉爽到我忍不住想出去多走走而不是待在寝室，明天下午去踢球，虽然全是陌生人，但也应该跳出自己的舒适圈，多出去闯闯了！\r\n现在，休息，休息一会儿~\r\n![](https://upload-images.jianshu.io/upload_images/9031347-45e2443c56a48163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n\r\n\r\n');
INSERT INTO `article_content` VALUES (23, '> 转自：https://medium.freecodecamp.org/learn-these-4-things-and-working-with-lambda-expressions-b0ab36e0fffc\r\n\r\nBefore Lambda expressions support was added by JDK 8, I’d only used examples of them in languages like C# and C++.\r\n\r\nOnce this feature was added to Java, I started looking into them a bit closer.\r\n\r\nThe addition of lambda expressions adds syntax elements that increase the expressive power of Java. In this article, I want to focus on foundational concepts you need to get familiar with so you can start adding lambda expressions to your code today.\r\n\r\n#### Quick Introduction\r\n\r\nLambda expressions take advantage of parallel process capabilities of multi-core environments as seen with the support of pipeline operations on data in the Stream API.\r\n\r\nThey are anonymous methods (methods without names) used to implement a method defined by a functional interface. It’s important to know what a functional interface is before getting your hands dirty with lambda expressions.\r\n\r\n#### Functional interface\r\n\r\nA functional interface is an interface that contains one and only one abstract method.\r\n\r\nIf you take a look at the definition of the Java standard [Runnable interface](https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html), you will notice how it falls into the definition of functional interface because it only defines one method: `run()`.\r\n\r\nIn the code sample below, the method `computeName` is implicitly abstract and is the only method defined, making MyName a functional interface.\r\n\r\n```java\r\ninterface MyName{\r\n  String computeName(String str);\r\n}\r\n```\r\n\r\n#### The Arrow Operator\r\nLambda expressions introduce the new arrow operator -> into Java. It divides the lambda expressions in two parts:\r\n```java\r\n(n) -> n*n\r\n```\r\nThe left side specifies the parameters required by the expression, which could also be empty if no parameters are required.\r\n\r\nThe right side is the lambda body which specifies the actions of the lambda expression. It might be helpful to think about this operator as “becomes”. For example, “n becomes n*n”, or “n becomes n squared”.\r\n\r\nWith functional interface and arrow operator concepts in mind, you can put together a simple lambda expression:\r\n```java\r\ninterface NumericTest {\r\n	boolean computeTest(int n); \r\n}\r\n\r\npublic static void main(String args[]) {\r\n	NumericTest isEven = (n) -> (n % 2) == 0;\r\n	NumericTest isNegative = (n) -> (n < 0);\r\n\r\n	// Output: false\r\n	System.out.println(isEven.computeTest(5));\r\n\r\n	// Output: true\r\n	System.out.println(isNegative.computeTest(-5));\r\n}\r\n```\r\n```java\r\ninterface MyGreeting {\r\n	String processName(String str);\r\n}\r\n\r\npublic static void main(String args[]) {\r\n	MyGreeting morningGreeting = (str) -> \"Good Morning \" + str + \"!\";\r\n	MyGreeting eveningGreeting = (str) -> \"Good Evening \" + str + \"!\";\r\n  \r\n  	// Output: Good Morning Luis! \r\n	System.out.println(morningGreeting.processName(\"Luis\"));\r\n	\r\n	// Output: Good Evening Jessica!\r\n	System.out.println(eveningGreeting.processName(\"Jessica\"));	\r\n}\r\n```\r\nThe variables morningGreeting and eveningGreeting, lines 6 and 7 in the sample above, make a reference to MyGreeting interface and define different greeting expressions.\r\n\r\nWhen writing a lambda expression, it is also possible to explicitly specify the type of the parameter in the expression like this:\r\n```java\r\nMyGreeting morningGreeting = (String str) -> \"Good Morning \" + str + \"!\";\r\nMyGreeting eveningGreeting = (String str) -> \"Good Evening \" + str + \"!\";\r\n```\r\n#### Block Lambda Expressions\r\nSo far, I have covered samples of single expression lambdas. There is another type of expression used when the code on the right side of the arrow operator contains more than one statement known as block lambdas:\r\n```java\r\ninterface MyString {\r\n	String myStringFunction(String str);\r\n}\r\n\r\npublic static void main (String args[]) {\r\n	// Block lambda to reverse string\r\n	MyString reverseStr = (str) -> {\r\n		String result = \"\";\r\n		\r\n		for(int i = str.length()-1; i >= 0; i--)\r\n			result += str.charAt(i);\r\n		\r\n		return result;\r\n	};\r\n\r\n	// Output: omeD adbmaL\r\n	System.out.println(reverseStr.myStringFunction(\"Lambda Demo\")); \r\n}\r\n```\r\n#### Generic Functional Interfaces\r\nA lambda expression cannot be generic. But the functional interface associated with a lambda expression can. It is possible to write one generic interface and handle different return types like this:\r\n```java\r\ninterface MyGeneric<T> {\r\n	T compute(T t);\r\n}\r\n\r\npublic static void main(String args[]){\r\n\r\n	// String version of MyGenericInteface\r\n	MyGeneric<String> reverse = (str) -> {\r\n		String result = \"\";\r\n		\r\n		for(int i = str.length()-1; i >= 0; i--)\r\n			result += str.charAt(i);\r\n		\r\n		return result;\r\n	};\r\n\r\n	// Integer version of MyGeneric\r\n	MyGeneric<Integer> factorial = (Integer n) -> {\r\n		int result = 1;\r\n		\r\n		for(int i=1; i <= n; i++)\r\n			result = i * result;\r\n		\r\n		return result;\r\n	};\r\n\r\n	// Output: omeD adbmaL\r\n	System.out.println(reverse.compute(\"Lambda Demo\")); \r\n\r\n	// Output: 120\r\n	System.out.println(factorial.compute(5)); \r\n\r\n}\r\n```\r\n\r\n#### Lambda Expressions as arguments\r\nOne common use of lambdas is to pass them as arguments.\r\n\r\nThey can be used in any piece of code that provides a target type. I find this exciting, as it lets me pass executable code as arguments to methods.\r\n\r\nTo pass lambda expressions as parameters, just make sure the functional interface type is compatible with the required parameter.\r\n```java\r\ninterface MyString {\r\n	String myStringFunction(String str);\r\n}\r\n\r\npublic static String reverseStr(MyString reverse, String str){\r\n  return reverse.myStringFunction(str);\r\n}\r\n\r\npublic static void main (String args[]) {\r\n	// Block lambda to reverse string\r\n	MyString reverse = (str) -> {\r\n		String result = \"\";\r\n		\r\n		for(int i = str.length()-1; i >= 0; i--)\r\n			result += str.charAt(i);\r\n		\r\n		return result;\r\n	};\r\n\r\n	// Output: omeD adbmaL\r\n	System.out.println(reverseStr(reverse, \"Lambda Demo\")); \r\n}\r\n```\r\n\r\nThese concepts will give you a good foundation to start working with lambda expressions. Take a look at your code and see where you can increase the expressive power of Java.\r\n');
INSERT INTO `article_content` VALUES (24, '# 一、java中的基本类型\r\njava中一共有9中基本类型：\r\n|类型名称|默认值|大小|最小值|最大值|包装类|缓存区间|\r\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\r\n|boolean|false|1B|0（false）|1（true）|Boolean|无|\r\n|byte|（byte）0|1B|-128|127|Byte|-128~127|\r\n|char|\'\\u0000\'|2B|\'\\u0000\'|\'\\uFFFF\'|Character|(char)0~(char)127|\r\n|short|(short)0|2B|$-2^{15}$|$-2^{15}-1$|Short|-128~127|\r\n|int|0|4B|$-2^{16}$|$2^{16}-1$|Integer|-128~127|\r\n|long|0L|8B|$-2^{32}$|$2^{32}-1$|Long|-128~127|\r\n|float|0.0F|4B|1.4e-45|3.4e+38|Float|无|\r\n|double|0.0D|8B|4.9e-324|1.798e+308|Double|无|\r\n|refObj||4B|||||\r\n> 以上基本类型的默认值都是各种不同形式的0，需要注意的是：\r\n▲在java中没有针对boolean对象的专门字节码表示，boolean = false表示的就是ICONST_0，也就是常数0赋值，但是在java中```boolean b = 0```编译不会通过！\r\n▲char变量的默认值是\'\\u0000\'，\\u表示的是unicode码，\'\\u0000\'表示NUL（注意不是null），在码表中的第一个，是一个空的不可见字符，其码值为0。\r\n▲缓存区间表示的是某些基本类型的包装类已经缓存了部分的数值，当我们新建某种类型的包装类时，会先检查下该包装类的值是否在区间中，如果在就复用已有对象，没有就新建一个！\r\n\r\n> 另外还有一种基本类型refobj表示对其他类对象的应用，这里暂不讨论！\r\n\r\n> 以上内容来自《码出高效，java开发手册》\r\n\r\n# 二、byte、short、int、long\r\njava的整型基本变量都是用补码形式存在于计算机中的。最高位表示的是符号位，后面的表示数值部分！结合代码实例：\r\n```java\r\n        System.out.println(Integer.toBinaryString(9));// 1001\r\n        System.out.println(Integer.toBinaryString(-9));// 11111111111111111111111111110111\r\n```\r\n> 正数：\r\n9对应的二进制是1001，从上述表格中可以知道一共整型**大小为4B**，一共32位二进制位，**且为正数**，所以**高位补0**，而且对于正数**原码=补码=反码**，然后显示出来高位的0自动省略，所以显示是1001，而对应的存储在计算机中的二进制其实是\r\n0000 0000 0000 0000 0000 1001。\r\n\r\n>负数：\r\n负数的原码求补码的方式是：\r\n$$\r\ny=\\begin{cases}\r\nx\\quad 2^n>x\\geq 0 \\\\\\\\\r\n2^{n+1}+x\\quad 0>x>-2^n\r\n\\end{cases}\r\n$$\r\n所以-9的补码就是10111，然后高位补1（因为是负数）所以显示的是\r\n1111 1111 1111 1111 1111 1111 1111 0111\r\n\r\n##Q&A\r\n> 1. 以byte为例，为什么byte基本类型是 128~127即$-2^7$ ~ $2^7-1$？\r\n答：对于数字0，+0和-0的补码分别是0,0000000和1,0000000。在java中，我们没必要用两个补码表示一个数字，而-128的补码也是1,0000000（没有原码和反码），所以可以定义1,0000000表示-128，这样既可不用两个补码表示一个数，还能增大byte的范围（具体转换过程略！）（其他整形基本变量同理！）\r\n\r\n> 2. 为什么要有补码、反码和移码？\r\n答：\r\n[原码、反码、补码的产生、应用以及优缺点有哪些？ - DADAman的回答 - 知乎](https://www.zhihu.com/question/20159860/answer/71256667)\r\n# 三、float、double\r\n在java中，浮点数的表示都依据 IEEE 754 标准，该标准为 32 位浮点和 64 位双精度浮点二进制小数定义了二进制标准。其存储形式为科学计数法形式，不能保证数据的精确性，所以当我们想要进行准确的计算时可以用BigDecimal类对象。\r\nfloat和double的计算机存储形式如下图所示：\r\n![](https://upload-images.jianshu.io/upload_images/9031347-b1a000a1542e35ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![来自https://blog.csdn.net/zq602316498/article/details/41148063](https://upload-images.jianshu.io/upload_images/9031347-869352b5201edd74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n> **符号位**表示的是这个浮点数的正负号，为0则为正，为1则为负。\r\n**指数**部分包含指第一位的数符和后面的数值部分，其也叫作**阶数**和其符号也可叫**阶符**。\r\n**尾数**部分的要求：因为基数为2 ，所以IEEE要求尾数部分的小数第一个二进制位一定为1。因为这个条件一定，所以我们可以把第一位的1给隐含掉，这样就能又多一位表示尾数部分，增大了该浮点类型的表示范围！\r\n\r\n> 我们用例题加以理解：\r\n1.将$+\\frac{19}{128}$写成二进制定点数、浮点数及在定点机和浮点机中的及其数形式。（其中指数部分为5位，数符1位，数值部分10位）\r\n\r\n解：设x = $+\\frac{19}{128}$\r\n二进制表现形式为：x=0.0010011\r\n定点表示：                 x=0.001001100（数值部分10位，补齐0）\r\n浮点格式化形式：     x=$0.100110000 × 2^{-10}$\r\n定点机中表示为：    $[x]_{原}$ = $[x]_{反}$ = $[x]_{补}$ =0.00 1001100（同上）\r\n浮点机中表示为：    \r\n    -  $[x]_{原}$ = 0 1,0010 0011000000\r\n    -  $[x]_{反}$ = 0 1,1110   0011000000\r\n    -  $[x]_{补}$ = 0 1,1101   0011000000\r\n> 上述：\r\n第一个0为符号位，因为x为正数，所以此为0；\r\n第二个字段表示的是指数部分，第一位自然为符号位1，后面跟着指数数值部分，因为是负数，所以原码反码部分都不一样。\r\n第三个字段为数值字段，根据前面所说第一位1隐含起来，然后后面补0补齐10位即可。即0011000000。\r\n\r\n## Q&A\r\n> 1. float的取值范围如何计算？\r\n![](https://upload-images.jianshu.io/upload_images/9031347-466361d94dff3e55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n先不讨论float的取值范围，我们先假设一个浮点数类型位数部分为n位，指数部分为m位。所以：\r\n```最大正数：```应该**尾数**全为1（$1-2^{-n}$），**指数**为正数且也全为1（$2^m-1$）即**$(1-2^{-n})× 2^{(2^m-1)}$**。\r\n```最小正数：```应该**尾数**为0.100...（既要符合规范又要最小，只能这样）**指数**部分为负数且为全1，这样方可保证后面的2的次方最小即（$2^{-(2^m-1)}$）,所以最小正数为：**$0.1×2^{-(2^m-1)}$**。\r\n```最大负数：```**尾数**应该为0.100...，然后指数应该尽可能地小同最小正数，所以最大负数为**$-0.1×2^{-(2^m-1)}$**。\r\n```最小负数：```尾数应同最大正数，但为负数，指数同最大正数，所以最小负数为：**$-(1-2^{-n})×2^{ (2^m-1)}$**。\r\n现在我们回到float的取值范围的计算，前面我们讲了，float的指数位数为8位（包含指数数符），尾数位数为23位（不包含数符），所以代入公式，取值范围为(注意这里的尾数计算按24位计算，因为第一个1是隐含的！）：\r\n$-(1-2^{-24})×2^{127}$~$-2^{-128}$ 和 $2^{-128}$~$ (1-2^{-24})×2^{127}$\r\n就不做进一步计算了！\r\n\r\n> 2. float和double的精度如何计算？\r\nfloat和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。\r\nfloat：2^23 = 8388608，一共七位，由于最左为1的一位省略了，这意味着最多能表示8位数： 2*8388608 = 16777216 。有8位有效数字，但绝对能保证的为7位，也即float的精度为7~8位有效数字；\r\ndouble：2^52 = 4503599627370496，一共16位，同理，double的精度为16~17位。\r\n\r\n# 四、char、boolean\r\n等我先研究研究\r\n\r\n\r\n参考：https://blog.csdn.net/zq602316498/article/details/41148063\r\n');
INSERT INTO `article_content` VALUES (25, '> 参考博客：[HTTP协议（一）之HTTP协议详解](https://www.jianshu.com/p/f8810462e5ba)\r\n\r\n# HTTP协议\r\nHTTP(HyperText Transfer Protocol)协议是运行在应用层的超文本传输协议。\r\n> 书上举例：把网络请求比喻成发电报，我们将电报内容以摩尔斯电码的形式发出去，要先将内容翻译成摩尔斯电码，即编码。接受者接受到“滴滴滴”的信息，需要解码成人类能看得懂的内容。在网络传输过程中，http协议执行的功能就是编码解码操作。\r\n\r\n### HTTP报文\r\nHTTP报文结构很重要的。可以分为请求报文（Request Message）和响应报文（Response Message）。两者在结构上大致相同，在内容上有很多不同。\r\n每个报文的基本结构可分为三部分：首行，头部和主体，两者内容分别如下所示：\r\n**请求报文结构：**\r\n首行：有三个内容即请求方式、URL和HTTP版本\\r\\n\r\n头部：采用键值对方式（用：隔开）描述相关属性，如请求编码等\\r\\n\r\n\\r\\n\r\n主体：是POST请求的参数\r\n**响应报文结构：**\r\n首行：状态码、HTTP版本和具体原因（可以没有）\\r\\n\r\n头部：同上\\r\\n\r\n\\r\\n\r\n主体：网页要显示的内容\r\n\r\n> HTTP请求方式有 POST、GET、DELETE、HEAD和PUT。\r\n### 状态码\r\n状态码（status）标记的是网页响应状态结果：\r\n|状态码|类别|示例|\r\n|:--:|:--:|:--:|\r\n|1XX|信息性状态码|书上没有例子|\r\n|2XX|成功状态码|200表示请求成功|\r\n|3XX|重定向状态码|301表示请求重定向|\r\n|4XX|客户端错误状态码|404表示找不到请求的资源|\r\n|5XX|服务端错误状态码|500表示内部错误|\r\n\r\n### http报文消息头\r\n请求和相应报文的消息行下面都会有一连串的键值对似的消息头，平常的网络活动中，消息行不能表示所有信息，我们还需要额外的详细信息如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器所使用的软件名称、版本和数据有效期、版本号等。然后一行空行后就是消息体。\r\n消息有的属性较多，写点常见的好理解的吧：\r\n\r\n|属性|作用|举例|\r\n|:--:|:--|:--:|\r\n|Cache-Control|这个指令很重要，用来指定请求和响应的缓存机制|所有的属性值有：public（可以被任何缓存所缓存）、private（内容只缓存到私有缓存中）、no-cache（所有内容都不可被缓存）|\r\n|Accept|指定浏览器可以接受的媒体类型，比如text/html就是接受我们常说的html文档，如果要接收jpg图片这里就可以指定image/jpg|Accept-Encoding：text/html|\r\n|Accept-Encoding|指明浏览器接收的编码方式，通常指定的是数据压缩的方式，比如是否支持压缩，支持什么压缩|Accept-Encoding: gzip, deflate, br|\r\n|Accept-Language|指定浏览器所用语言，注意语言和字符集是有区别的，语言可能有很多字符集，比如中文是语言而中文有字符集UTF-8、gb2312、gbk等|Accept-Language:zh-CN,zh;q=0.9,en-US;q=0.8,en-GB;q=0.7,en;q=0.6|\r\n|User-Agent|告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。|User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36，具体含义都不是太明白，发现一篇[文章](http://www.cnblogs.com/ifantastic/p/3481231.html)写的很好，基本上有的内容都包含了！|\r\n|Accept-Charset|浏览器声明自己使用的字符集|Accept-charset=\"ISO-8859-1\"|\r\n|Content-Length|指明发送请求内容的长度|Content-LEngth：38|\r\n|Content-Type|声明请求数据的类型|Content-Type: application/x-www-form-urlencoded|\r\n|Connection|Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接|Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。|\r\n|Host|这个很必须，表示的是请求的服务器ip和端口信息，是从url中剥离出来的|Host：localhost:8080|\r\n|Location|指明一个重定向到的url地址|存在于响应报文中，当状态码是304需要重定向时使用|\r\n\r\n![自己接收到的报文信息](https://upload-images.jianshu.io/upload_images/9031347-d5eeb44a76526231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n### http报文消息体\r\n据我所知，消息体中一般存在如post所附属性，返回的html文档内容等！消息体在报文的空行下。\r\n\r\n### 使用NioSocket获取报文信息并显示内容\r\n了解到网页请求的形式是以包的形式发出，所遵循的协议是tcp，到达浏览器，内容由http所规范，以字节形式存在于数据包中，所以我们在代码中可以使用niosocket监听本机的8080端口（本来想监听80端口，可是已经被占用），然后获取其所包含的字节缓存到ByteBuffer中，然后转换成字符换，显示出来即可！\r\n\r\n代码如下（在这里充当的是web服务器的角色，所以只写了服务器，请求由浏览器发出！）：\r\n\r\n```java\r\npackage AboutNioSocket.ImplementTheHttpProtocolwWithNioSocket;\r\n\r\nimport java.io.IOException;\r\nimport java.net.InetSocketAddress;\r\nimport java.nio.channels.SelectionKey;\r\nimport java.nio.channels.Selector;\r\nimport java.nio.channels.ServerSocketChannel;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * @author hsw\r\n * @create 2018-09-27  19:54\r\n */\r\npublic class HttpServer {\r\n    private ServerSocketChannel channel = null;\r\n    private Selector selector = null;\r\n    public static void main(String[] args) {\r\n        new HttpServer().start();\r\n    }\r\n\r\n    private void start() {\r\n\r\n        try {\r\n            channel = ServerSocketChannel.open();\r\n            channel.configureBlocking(false);\r\n        } catch (IOException e) {\r\n            System.out.println(\"服务器创建失败 原因：ServerSocketChannel对象打开或设置非阻塞失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            selector = Selector.open();\r\n            channel.register(selector, SelectionKey.OP_ACCEPT);\r\n        } catch (IOException e) {\r\n            System.out.println(\"服务器创建失败 原因：Selector打开或注册失败\");\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            channel.bind(new InetSocketAddress(8080));\r\n        } catch (IOException e) {\r\n            System.out.println(\"服务器创建失败 原因：channel绑定端口失败！\");\r\n            e.printStackTrace();\r\n        }\r\n\r\n        beginAccept();\r\n    }\r\n\r\n    private void beginAccept() {\r\n        while (true) {\r\n            try {\r\n                if (selector.select(3000) == 0) {\r\n                    System.out.println(\"未接受到请求！\");\r\n                    continue;\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"selector处理请求失败！\");\r\n                e.printStackTrace();\r\n            }\r\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\r\n            while (iter.hasNext()) {\r\n                SelectionKey key = iter.next();\r\n                iter.remove();\r\n                new Thread(new HttpRequestHandler(key)).run();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nHttpHandler类代码：\r\n```java\r\npackage AboutNioSocket.ImplementTheHttpProtocolwWithNioSocket;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.*;\r\nimport java.nio.charset.Charset;\r\n\r\n/**\r\n * @author hsw\r\n * @create 2018-09-27  20:20\r\n */\r\npublic class HttpRequestHandler implements Runnable {\r\n\r\n    private static final String CHARSET = \"UTF-8\";\r\n    private static final int BUFFER_SIZE = 1024;\r\n    private SelectionKey key;\r\n\r\n    public HttpRequestHandler(SelectionKey key) {\r\n        this.key = key;\r\n    }\r\n\r\n    private void acceptHttpRequest() {\r\n        SocketChannel socketChannel = null;\r\n        try {\r\n            socketChannel = ((ServerSocketChannel) key.channel()).accept();\r\n            socketChannel.configureBlocking(false);\r\n        } catch (IOException e) {\r\n            System.out.println(\"accept错误！\");\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            socketChannel.finishConnect();\r\n        } catch (IOException e) {\r\n            System.out.println(\"完成连接失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        Selector selector = key.selector();\r\n        try {\r\n            socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));\r\n        } catch (ClosedChannelException e) {\r\n            System.out.println(\"handler中注册selector失败！\");\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private String readHttpRequest() {\r\n        String httpStr = \"\";\r\n        SocketChannel channel = (SocketChannel) key.channel();\r\n        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();\r\n        byteBuffer.clear();\r\n        int num;\r\n        try {\r\n            if ((num = channel.read(byteBuffer)) != -1) {\r\n                byteBuffer.flip();\r\n                httpStr = Charset.forName(CHARSET).newDecoder().decode(byteBuffer).toString();\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(\"服务器读取错误！\");\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return httpStr;\r\n    }\r\n\r\n    private String turnStringToHttpPackage(String httpPackageStr) {\r\n\r\n        return httpPackageStr;\r\n    }\r\n\r\n//我们可以在这里将字符串转换成我们想要的格式！\r\n    private void returnHttpPackage(String returnHttpStr) {\r\n        System.out.println(returnHttpStr);\r\n    }\r\n\r\n    @Override\r\n\r\n    public void run() {\r\n        if (key.isAcceptable()) {\r\n            acceptHttpRequest();\r\n        } else if (key.isReadable()) {\r\n            returnHttpPackage(turnStringToHttpPackage(readHttpRequest()));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n> 这里是接收并显示所获取的http请求，返回报文下面实现！\r\n\r\n> [NioSocket的简单使用](https://www.jianshu.com/p/c8860f46cac6)\r\n\r\n在浏览器中输入```localhost:8080```即可在编译器中看到：\r\n![](https://upload-images.jianshu.io/upload_images/9031347-314c65c637b02437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n> 可以看到请求方法为GET，所以在Accept-Language的下一行为空行，而空行下面即请求体没有内容！\r\n\r\n### 返回报文\r\n\r\n我们只需修改returnHttpPackage方法中添加代码：\r\n```java\r\n  private void returnHttpPackage(String httpPackageStr) {\r\n        StringBuilder returnStr = new StringBuilder();\r\n        returnStr.append(\"HTTP/1.1 200 ok\\r\\n\");//增加响应消息行\r\n        returnStr.append(\"Content-Type:text/html;charset=\" + CHARSET + \"\\r\\n\");//增加响应消息头\r\n        returnStr.append(\"\\r\\n\");//空行\r\n        returnStr.append(\"<!DOCTYPE html>\\n\" +\r\n                \"<html lang=\\\"en\\\">\\n\" +\r\n                \"<head>\\n\" +\r\n                \"    <meta charset=\\\"UTF-8\\\">\\n\" +\r\n                \"    <title>返回的网页</title>\\n\" +\r\n                \"    <style>\\n\" +\r\n                \"        *{\\n\" +\r\n                \"            background-color: cadetblue;\\n\" +\r\n                \"        }\\n\" +\r\n                \"        #requestInfo{\\n\" +\r\n                \"            font-size: 35px;\\n\" +\r\n                \"            font-family: \\\"Buxton Sketch\\\",serif;\\n\" +\r\n                \"            font-weight: bold;\\n\" +\r\n                \"            color: #001bff;\\n\" +\r\n                \"        }\\n\" +\r\n                \"    </style>\\n\" +\r\n                \"</head>\\n\" +\r\n                \"<body>\\n\" +\r\n                \"    <h1>Hello!</h1><br>\\n\" +\r\n                \"    <h3>I\'m come from localhost!</h3>\\n\" +\r\n                \"    <h3>And this is you request package information：</h3><br>\\n\" +\r\n                \"    <p id=\\\"requestInfo\\\">\\n\" +\r\n                httpPackageStr +     //返回请求头信息！\r\n                \"        \\n\" +\r\n                \"    </p>\\n\" +\r\n                \"</body>\\n\" +\r\n                \"</html>\");//响应消息体\r\n\r\n        System.out.println(\"返回内容：\\n\" + returnStr.toString());\r\n\r\n        SocketChannel channel = (SocketChannel) key.channel();\r\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\r\n        buffer.clear();\r\n        try {\r\n            buffer.put(returnStr.toString().getBytes(CHARSET));\r\n        } catch (UnsupportedEncodingException e) {\r\n            System.out.println(\"返回内容字节转换失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n            buffer.flip();\r\n            channel.write(buffer);\r\n        } catch (IOException e) {\r\n            System.out.println(\"报文返回失败！\");\r\n            e.printStackTrace();\r\n        }\r\n        try {\r\n                channel.close();\r\n            } catch (IOException e) {\r\n                System.out.println(\"channel关闭错误！\");\r\n                e.printStackTrace();\r\n        }\r\n    }\r\n```\r\n再次请求吗，显示效果如下：\r\n![网页丑陋，见谅](https://upload-images.jianshu.io/upload_images/9031347-276b3cb73a833b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n或者可以直接在网页中复制html文件内容也可！');
INSERT INTO `article_content` VALUES (26, '参考大神的博客：https://blog.csdn.net/zengxiantao1994/article/details/77803960\r\n# Pattern的创建：\r\n**Pattern的构造器被保护了起来，创建Pattern对象要靠使用compile方法编译正则表达式的返回Pattern的对象实例来实现！**\r\n两种compile方法：\r\n```java\r\npublic class testCompileMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*.+[1-9]\\\\d*=?\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        System.out.println(pattern.pattern());\r\n        System.out.println(pattern.flags());\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-98d5e1a713c2681c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n> 使用**pattern.pattern()**获取编译的正则表达式，而**flags()**获得的是使用compile（String regex，int falg）创建Pattern对象时设置的！flag是用来控制正则表达式匹配行为的，默认值为0！\r\n\r\nPattern有几个内置的flag类型及作用：\r\n|名字|作用|十六进制值|\r\n|:--:|:--:|:--:|\r\n|Pattern.CANON_EQ|启用规范等价。当且仅当两个字符的“正规分解(canonicaldecomposition)”都完全相同的情况下，才认定匹配。默认情况下，不考虑“规范相等性(canonical equivalence)”。|0x80|\r\n|Pattern.CASE_INSENSITIVE|启用不区分大小写的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配，要想对Unicode字符进行大小不敏感的匹配，只要将UNICODE_CASE与这个标志合起来就行了。|0x02|\r\n|Pattern.COMMENTS|模式中允许空白和注释。在这种模式下，匹配时会忽略(正则表达式里的)空格字符(不是指表达式里的“\\s”，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。|0x04|\r\n|Pattern.DOTALL|启用dotall模式。在这种模式下，表达式‘.’可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式‘.’不匹配行的结束符。|0x20|\r\n|Pattern.LITERAL|启用模式的字面值解析。|0x10|\r\n|Pattern.MULTILINE|启用多行模式。在这种模式下，‘\\^’和‘$’分别匹配一行的开始和结束。此外，‘^’仍然匹配字符串的开始，‘$’也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。|0x08|\r\n|Pattern.UNICODE_CASE|启用Unicode感知的大小写折叠。在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不敏感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。|0x40|\r\n|Pattern.UNIX_LINES|启用Unix行模式。在这个模式下，只有‘\\n’才被认作一行的中止，并且与‘.’、‘^’、以及‘$’进行匹配。|0x01|\r\n# Pattern之使用split进行字符串分割\r\n使用Pattern对象编译的正则表达式所匹配的子字符串对字符串进行分割：\r\n```java\r\npublic class testSplitMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[+\\\\-*/]\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        String []nums = pattern.split(\"13+29-44*55/22\");\r\n        for (String num : nums) {\r\n            System.out.print(num + \" \");\r\n        }\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9faf255b8113b76f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n将split方法改成：\r\n```java\r\nString []nums = pattern.split(\"13+29-44*55/22\", 2);\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9bd6c53b09cef895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n>即后面的整数类型入参觉得的是字符串被分割后的段数\r\n# Pattern使用matchs进行字符串的全匹配\r\npattern的matches方法对字符串进行一次匹配，只有全部符合规则才能返回true！\r\n```java\r\npublic class testMatchesMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*[+\\\\-*/][1-9]\\\\d*=?\";\r\n        System.out.println(Pattern.matches(regex, \"2315+5555=\"));\r\n        System.out.println(Pattern.matches(regex, \"123456*4556\"));\r\n        System.out.println(Pattern.matches(regex, \"0112897+440=\"));\r\n        System.out.println(Pattern.matches(regex, \"22+023\"));\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-62de709f6586526a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n# Pattern的matcher（CharSequence input）方法\r\n该方法返回的是一个Matcher对象，Matcher类的构造方法也被peivate保护了起来，只能使用这个方法创建，Pattern类只能做一些简单的匹配操作，要想得到更强更便捷的正则匹配操作，那就需要将Pattern与Matcher一起合作。Matcher类提供了对正则表达式的分组支持，以及对正则表达式的多次匹配支持。\r\n```java\r\npublic class testMatcherMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*[+\\\\-*/][1-9]\\\\d*=?\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"1+2\");\r\n        System.out.println(matcher.pattern());\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9429fa7aecb67f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n> 可以看出Matcher的pattern的方法也是显示生成自己的pattern编译的正则表达式！\r\n# Matcher类方法详解：\r\n## matches（String content）\r\n和Pattern的matches方法一样，不赘述\r\n## lookAt（）方法\r\n与字符串的前缀匹配。\r\n```java\r\npublic class testCompileMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*[+\\\\-*/][1-9]\\\\d*=?\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"1+2dasfdsadfeeesdfxca\");\r\n        System.out.println(matcher.lookingAt());\r\n        matcher = pattern.matcher(\"a1+2asdfasdfsadf\");\r\n        System.out.println(matcher.lookingAt());\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-5386e3bf7a9e6c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n## find（）方法\r\n在字符串中找是否有匹配的子字符串，有则返回ture\r\n```java\r\npublic class testCompileMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*[+\\\\-*/][1-9]\\\\d*=?\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"asdfasd11+2dasfdsadfeeesdfxca\");\r\n        System.out.println(matcher.find());\r\n        matcher = pattern.matcher(\"asdfasd12dasfdsadfeeesdfxca\");\r\n        System.out.println(matcher.find());\r\n        matcher = pattern.matcher(\"1+1\");\r\n        System.out.println(matcher.find());\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-b297918ef81b112d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n## start（）和end（）方法\r\n前者是返回匹配到的字符串的第一个字符在字符串中的索引，后者则返回最后一个的索引+1\r\n```java\r\npublic class testCompileMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"[1-9]\\\\d*[+\\\\-*/][1-9]\\\\d*=?\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsadfeeesdfxca\");\r\n        if (matcher.find()) {\r\n            System.out.println(\"The index of the final one character is \" + matcher.start());\r\n            System.out.println(\"The index of the last one character is \" + matcher.end());\r\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group());\r\n        }\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-a87135021511999b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n> 只有有匹配的子字符串的情况时才可以调用者几个方法，否则报错！\r\n\r\n## 对匹配到的字符串进行分割操作\r\n在正则表达式中使用括号对想要分割的方式进行添加！\r\n举例：\r\n```java\r\npublic class testCompileMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"([1-9]\\\\d*)([+\\\\-*/])([1-9]\\\\d*=?)\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsadfeeesdfxca\");\r\n\r\n        System.out.println(matcher.find());\r\n\r\n        System.out.println(matcher.groupCount());\r\n\r\n        for (int i = 0; i <= matcher.groupCount(); i++) {\r\n            System.out.println(\"The index of the final one character is \" + matcher.start(i));\r\n            System.out.println(\"The index of the last one character is \" + matcher.end(i));\r\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group(i));\r\n        }\r\n    }\r\n}\r\n```\r\n> 注意对正则表达式的分割\r\n\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-df273d5e588e15a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n由图片可以看出，matcher中的group第一个显示的是匹配到的字符串及其信息后面才是我们分割的结果！\r\n\r\n## 一个字符串有多个匹配的子字符串的情况\r\n如果有多个匹配到的字符串，多用几次find就可以了！find方法第一次调用只匹配字符串中第一个匹配到的字符串，再调一次匹配第二个，以此类推！\r\n如在上面一段代码稍稍修改下：\r\n```java\r\npublic class testFindMethodInPattern {\r\n    public static void main(String[] args) {\r\n        String regex = \"([1-9]\\\\d*)([+\\\\-*/])([1-9]\\\\d*=?)\";\r\n        Pattern pattern = Pattern.compile(regex);\r\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsa11+22esdfxca\");\r\n\r\n        System.out.println(matcher.find());\r\n        matcher.find();\r\n\r\n        System.out.println(matcher.groupCount());\r\n\r\n        for (int i = 0; i <= matcher.groupCount(); i++) {\r\n            System.out.println(\"The index of the final one character is \" + matcher.start(i));\r\n            System.out.println(\"The index of the last one character is \" + matcher.end(i));\r\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group(i));\r\n        }\r\n    }\r\n}\r\n```\r\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-1da5a9531d665f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n看！多调用一次find方法就匹配到第二段字符串了！\r\n\r\n####或者还可以在find方法中添加一个开始匹配的索引值，正则表达式只匹配这个整形参数索引后面的子字符串：\r\n```java\r\nmatcher.find(12)\r\n```\r\n效果和使用两次find的一样！\r\n');
INSERT INTO `article_content` VALUES (27, '> 重刷HDU，看到以前一个关于余数的题目，觉得相关余数的一些性质定理是时候总结下了！\r\n\r\n# 1. 概念：同余\r\n> 若a , b除以c的余数相等，则a与b相对于除数c是同余的，即a≡ b(mod c)！\r\n\r\n# 2.  同余的两个数的差能整除除数！\r\n > 如 10 % 3 = 1， 7 % 3 = 1，10≡ 7 (mod 3)则（10 - 7 ）% 3 = 0.\r\n\r\n# 3. 余数可加性（可减性同）\r\n两个数对于某个除数的余数和**对此除数的余数**等于两个数的和对此除数的余数！\r\n> 如 （11 % 3  + 8 % 3 ）% 3= （11 + 8） % 3\r\n题目：[hdu1021](http://acm.hdu.edu.cn/showproblem.php?pid=1021)\r\n\r\n# 4. 余数可乘性\r\n两个数对某个除数的余的乘积**对此除数的余数**等于两个数的乘积对此除数的乘积对此！\r\n> 如 [ （11%3 ）* （8%3 ） ]  % 3 = （11 * 8）%3\r\n题目： [hdu1005](http://acm.hdu.edu.cn/showproblem.php?pid=1005)\r\n\r\n# 5. 余数乘方性\r\n> 如果a与b除以m的余数相同，那么a^n与b^n除以m的余数也相同，但不一定等于原余数．\r\n例如：3，7除以4的余数都是3，可以算得3^2和7^2除以4的余数都等于1，它们的余数相等但不一定等于3.\r\n');
INSERT INTO `article_content` VALUES (28, '> 很是激动，离开ACM一年后还能找回当时ac时激动的感觉。虽然挺简单的一题，在苦思冥想之后想到左右子树分治采用递归解法。一次Compilation Error后就ac了。就算是重启刷题的开门红吧。\r\n\r\n### 这是原题：[ZOJ-1944](https://cn.vjudge.net/problem/29309/origin)\r\n\r\n答案：\r\n```c++\r\n//\r\n// Created by PC on 2019/2/28.\r\n// 通过前序遍历和中序遍历字母树获得的字符串获取后序遍历的字符串！\r\n// 深思熟虑后觉得应该用递归\r\n#include<iostream>\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stack>\r\nusing namespace std;\r\n// DBACEGF ABCDEFG\r\nstack<char> post;\r\n\r\n//先找出每个子树的根节点，然后获取其左子树和右子树\r\nvoid separateSubTree(char preOrder[], char inOrder[]) {\r\n\r\n    // 这是递归的判断\r\n    if(strlen(preOrder) == 0) {\r\n        return;\r\n    }\r\n    post.push(preOrder[0]);\r\n\r\n    // 根节点就是preOrder的第一个字母，根据根节点从inOrder中分成左右子树\r\n    // 这里的教训惨重啊，字符数组不赋初值，就会被自动赋一些乱七八糟的值，影响后面的结果！\r\n    char inLeft[20] = \"\", inRight[20] = \"\";\r\n    char preLeft[20] = \"\", preRight[20] = \"\";\r\n    char* middle = strchr(inOrder, preOrder[0]);\r\n\r\n    // 左子树\r\n    memcpy(inLeft, inOrder, middle - inOrder);\r\n\r\n    // 右子树\r\n    memcpy(inRight, middle + 1, strlen(inOrder) - 1 - (middle - inOrder));\r\n\r\n    //前面都是中序遍历的左右子树！下面获取前序遍历的左右子树，获取后直接再调用本方法获取就行了\r\n    // 左子树\r\n    memcpy(preLeft, preOrder + 1, strlen(inLeft));\r\n\r\n    // 右子树\r\n    memcpy(preRight, preOrder + strlen(inLeft) + 1, strlen(inRight));\r\n\r\n    separateSubTree(preRight, inRight);\r\n    separateSubTree(preLeft, inLeft);\r\n}\r\n\r\nint main() {\r\n    char preOrder[27], inOrder[27];\r\n    while (scanf(\"%s %s\", preOrder, inOrder) != EOF) {\r\n        // int postOrder[27];\r\n        separateSubTree(preOrder, inOrder);\r\n        //cout << post.size() << endl;\r\n        while (!post.empty()) {\r\n            cout << post.top();\r\n            post.pop();\r\n        }\r\n        cout << endl;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n');
INSERT INTO `article_content` VALUES (29, '> 感觉写的很好的两篇文章:[All You Need To Know About Processes in Linux ](https://www.tecmint.com/linux-process-management/)和[Processes in Linux/Unix](https://www.geeksforgeeks.org/processes-in-linuxunix/),本来想像文件权限那篇文章那样全文翻译过来，这样既能锻炼英语，又能加深linux相关知识。可是作业要紧，做完作业，找时间吧！\r\n\r\n转自[Linux查看和关闭正在执行的程序](https://my.oschina.net/u/1866459/blog/423732)\r\n\r\n#  有关进程的几种常用方法\r\n---\r\n### & 符号\r\n\r\n在执行某个命令的后面加上一个 & 符号，表示该命令放在后台执行.\r\n\r\n---\r\n### Jobs 命令\r\n\r\n该命令可以查看当前有多少在后台运行的命令，jobs 列出当前shell环境中已启动的任务状态，若未指定jobs id，则显示所有活动的任务状态信息。\r\njobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息。如：\r\n```\r\n[noc@dpi_netquery_new01 ~]$ jobs\r\n```\r\n\r\n> 当前任务的概念：如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]”的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”,\"stop”等命令时，如果不加任何引号，则所变动的均是当前任务。\r\n---\r\n### fg 命令（foreground）\r\n该命令将后台运行的进程调到前台来运行。 具体用法： fg %n。\r\n这里的N 是jobs 看到的job number。 如：\r\n```\r\n [noc@dpi_netquery_new01 ~]$ fg\r\n-bash: fg: current: no such job\r\n```\r\n\r\n---\r\n### ctrl + z 组合键\r\n该命令将一个正在前台执行的命令放到后台，并且暂停。\r\n\r\n---\r\n### bg命令（background）\r\n\r\n该命令将一个在后台暂停运行的命令，变成继续在后台执行的命令。\r\n用法：bg %n。 N 是jobs命令查看到的job number。 如：\r\n```\r\n[oracle@singledb ~]$ /u02/rman_incremental_backup.sh\r\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\r\n```\r\n--我们运行备份命令，然后按下CTRL+Z\r\n```\r\n[oracle@singledb ~]$ jobs\r\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\r\n```\r\n--用jobs查看进程状态\r\n```\r\n[oracle@singledb ~]$ fg %1\r\n/u02/rman_incremental_backup.sh\r\n```\r\n--用fg将进程调到前台运行\r\n```\r\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\r\n```\r\n--按下ctrl+z\r\n```\r\n[oracle@singledb ~]$ bg %1\r\n[1]+ /u02/rman_incremental_backup.sh &\r\n```\r\n--用bg将后台暂停的进程继续执行，这里自动加了一个& 符号\r\n```\r\n[oracle@singledb ~]$ jobs\r\n[1]+  Running                 /u02/rman_incremental_backup.sh &\r\n```\r\n--查看job 状态\r\n\r\n## 结束正在运行的进程\r\n### 结束前台进程\r\n这种只需要按下组合键： ctrl + c 即可。\r\n---\r\n### 结束后台运行的进程\r\n这种情况下也有两种方法：\r\n\r\n（1）用jobs查看进程的job number，然后用命令：kill %n 来结束。\r\n（2）用ps 查看进程的pid，然后用命令：kill pid 来结束。\r\n 这里对kill 做点说明，kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。\r\n```\r\n[oracle@singledb ~]$ kill -l\r\n\r\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\r\n\r\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\r\n\r\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\r\n\r\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\r\n\r\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\r\n\r\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\r\n\r\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\r\n\r\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\r\n\r\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\r\n\r\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\r\n\r\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\r\n\r\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\r\n\r\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\r\n\r\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\r\n\r\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\r\n\r\n63) SIGRTMAX-1  64) SIGRTMAX\r\n```\r\nSIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。\r\n\r\n---\r\n### ps 命令\r\n该命令用户列出系统中正在运行的进程。 常用的参数：ps -ef\r\n关于这2个参数含义，参考ps 命令的帮助：\r\n```\r\n[oracle@singledb ~]$ ps --help\r\n\r\n********* simple selection *********  ********* selection by list *********\r\n\r\n-A all processes                      -C by command name\r\n\r\n-N negate selection                   -G by real group ID (supports names)\r\n\r\n-a all w/ tty except session leaders  -U by real user ID (supports names)\r\n\r\n-d all except session leaders         -g by session OR by effective group name\r\n\r\n-e all processes                      -p by process ID\r\n\r\nT  all processes on this terminal     -s processes in the sessions given\r\n\r\na  all w/ tty, including other users  -t by tty\r\n\r\ng  OBSOLETE -- DO NOT USE             -u by effective user ID (supports names)\r\n\r\nr  only running processes             U  processes for specified users\r\n\r\nx  processes w/o controlling ttys     t  by tty\r\n\r\n*********** output format **********  *********** long options ***********\r\n\r\n-o,o user-defined  -f full            --Group --User --pid --cols --ppid\r\n\r\n-j,j job control   s  signal          --group --user --sid --rows --info\r\n\r\n-O,O preloaded -o  v  virtual memory  --cumulative --format --deselect\r\n\r\n-l,l long          u  user-oriented   --sort --tty --forest --version\r\n\r\n-F   extra full    X  registers       --heading --no-heading --context\r\n\r\n                    ********* misc options *********\r\n\r\n-V,V  show version      L  list format codes  f  ASCII art forest\r\n\r\n-m,m,-L,-T,H  threads   S  children in sum    -y change -l format\r\n\r\n-M,Z  security data     c  true command name  -c scheduling class\r\n\r\n-w,w  wide output       n  numeric WCHAN,UID  -H process hierarchy\r\n```\r\n\r\n# 前台进程和后台进程的一点讨论\r\n整理这篇文章的目的就是弄清楚在实际使用中这两种进程的区别。 一般情况下，我们都是通过shell 连接到linux 服务器上，那么，假如我们在这个shell 窗口执行一个备份或者其他命令，即前台命令。 在这个时候，前台命令没有执行完，我们把这个终端关闭了，那么这个命令也就会中断。 即使我们在执行命令时加了& 符号，让进程在后台执行，终端的关闭也会造成命令的结束。\r\n\r\n解决这个问题有两种方法：\r\n\r\n（1）将命令添加到crontab里，让系统自己调用。\r\n\r\n这种方法将使命令在服务器端执行，这样即使终端关闭，也不影响命令的执行。\r\n\r\n（2）使用nohup命令（no hang up）。\r\n\r\n该命令用于保证不挂断地运行命令。如：\r\n```\r\n[oracle@singledb ~]$ nohup /u02/rman_incremental_backup.sh &\r\n\r\n[1] 4409\r\n\r\n[oracle@singledb ~]$ jobs\r\n\r\n[1]+  Running                 nohup /u02/rman_incremental_backup.sh &\r\n```\r\n> 这里要注意：运行nohup命令后，按任意键返回shell 窗口，然后输入exit退出终端，不能直接关闭窗口，直接关闭窗口的话，还是会造成命令进程和终端一起结束。\r\n在Unix中永久的后台进程称为守护进程（daemon）。守护进程通常从系统启动时自动开始执行，系统关闭时才停止。而nohup 启动的进程虽然也是不中断的执行，但是当进程执行完毕后就会退出。\r\n\r\n\r\n\r\n\r\n\r\n\r\n');
INSERT INTO `article_content` VALUES (30, '### 错误描述：\r\n> 今天写linux的试验报告四，有一道题要修改系统应道程序的配置文件grub.conf（有些系统是menu.lst）让开机菜单的等待时间为10秒并在标题的后面加上自己姓名的拼音！可是在我找到这个配置文件的时候修改完，```w!```命令强制保存，提示的是只读文件打开但不能修改，然后搜索很多人说应该用```w !sudo %```命令，可是还是没用，然后就直接修改文件的只读文件为可写文件```chmod a+w filename```,提示该文件为系统只读文件，所以不能修改权限，我就很疑惑了。老师说```w！```肯定能强制保存的。\r\n\r\n### 错误解决：\r\n> 然后询问老师，老师说可能是最新版系统的vi单纯的只是vi，而不是vim的别名。\r\n于是``` yum install vim``` 下载vim，然后修改配置文件\r\n若要每次登入就自动生效别名，则把别名加在/etc/profile或~/.bashrc中。然后# source ~/.bashrc\r\n若要让每一位用户都生效别名，则把别名加在/etc/bashrc最后面，然后# source /etc/bashrc\r\n参考：https://blog.csdn.net/doiido/article/details/43762791\r\n');
INSERT INTO `article_content` VALUES (31, '## 目录\r\n\r\n[TOC]\r\n\r\n# 相关文件\r\n\r\n## /etc/passwd文件\r\n\r\n在/etc/passwd中，每一行都表示的是一个用户的信息；一行有7个段位；每个段位用:号分割，比如下面是/etc/passwd的一行：\r\n\r\n```linux\r\nbeinan:\\x:500:500:beinan sun:/home/beinan:/bin/bash\r\n```\r\n\r\n- **第一字段**：用户名（也被称为登录名）；在上面的例子中，我们看到这两个用户的用户名分别是beinan 和linuxsir；\r\n\r\n- **第二字段**：口令；在例子中我们看到的是一个x，其实密码已被映射到/etc/shadow 文件中；\r\n\r\n- **第三字段**：UID \r\n\r\n- **第四字段**：GID；用户的私有组号\r\n\r\n- **第五字段**：用户名全称，这是可选的，可以不设置，在beinan这个用户中，用户的全称是beinan sun ；而linuxsir 这个用户没有设置全称；\r\n\r\n- **第六字段**：用户的主目录所在位置；beinan 这个用户是/home/beinan ，而linuxsir 这个用户是/home/linuxsir ；\r\n\r\n- **第七字段**：用户所用SHELL 的类型，beinan和linuxsir 都用的是bash ；所以设置为/bin/bash （若为nologin，不能用账号和shell交互，只能通过应用程序登录）\r\n\r\n## /etc/shadow文件\r\n\r\n/etc/shadow文件的内容包括9个段位，每个段位之间用:号分割\r\n\r\n```\r\nbeinan:$1$VE.Mq2Xf$2c9Qi7EQ9JP8GKF8gH7PB1:13072:0:99999:7:::\r\n\r\nlinuxsir:$1$IPDvUhXP$8R6J/VtPXvLyXxhLWPrnt/:13072:0:99999:7::13108:\r\n```\r\n\r\n- **第一字段**：用户名（也被称之为登录名），在例子中有峡谷两条记录，也表示有两个用户beinan和linuxsir\r\n\r\n- **第二字段**：被加密的密码，如果有的用户在此字段中是x，表示这个用户不能登录系统，也可以看作是虚拟用户，不过虚拟用户和真实用户都是相对的，系统管理员随时可以对任何用户 操作；\r\n\r\n- **第三字段**：表示上次更改口令的天数（距1970年01月01日），上面的例子能说明beinan和linuxsir这两个用户，是在同一天更改了用户密码，当然是通过passwd 命令来更改的，更改密码的时间距1970年01月01日的天数为13072；\r\n\r\n- **第四字段**：密码的最小生存期，两次口令修改之间最小天数的功能。至少在这些天数之内不能修改密码。设置为0\r\n\r\n- **第五字段**：密码的最大生存期，两次修改口令间隔最多的天数，在这些天数之后必须修改密码。在例子中都是99999天；永远不需要更改密码。\r\n\r\n- **第六字段**：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将要作废；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_WARN_AGE 中定义；在例子中的值是7 ，表示在用户口令将过期的前7天警告用户更改期口令；\r\n\r\n- **第七字段**：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，系统会禁用此用户，也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用；在例子中，此字段两个用户的都是空的，表示禁用这个功能；\r\n\r\n- **第八字段**：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；在例子中，我们看到beinan这个用户在此字段是空的，表示此用户永久可用；而linuxsir这个用户表示在距1970年01月01日后13108天后过期，算起来也就是2005年11月21号过期。（此字段用的少，可用于收费会员服务）\r\n\r\n- **第九字段**：保留字段，目前为空，以备将来Linux发展之用；\r\n  注意：密码过期≠密码失效≠账号失效\r\n\r\n## /etc/group文件\r\n\r\n\r\n\r\n/etc/group 的内容包括用户组（Group）、用户组口令、GID及该用户组所包含的用户（User），每个用户组一条记录；格式如下：group_name:passwd:GID:user_list在/etc/group 中的每条记录分四个字段：\r\n\r\n- **第一字段**：用户组名称\r\n\r\n- **第二字段**：用户组密码，由于安全原因，已经不使用该字段保存密码，用”x”占位\r\n\r\n- **第三字段**：GID\r\n\r\n- **第四字段**：用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名（在group文件中，用户的主要组并不把该用户本身作为成员列出，只有附加组才把该用户作为成员列出。）\r\n\r\n## /etc/gshadow/文件\r\n\r\n\r\n\r\netc/gshadow是/etc/group的加密信息文件，/etc/gshadow 格式如下，每个用户组独占一行：\r\n\r\n```groupname:password:admin,admin,...:member,member,...```\r\n\r\n- **第一字段**：用户组名称\r\n\r\n- **第二字段**：用户组密码，这个段可以是空的或!，如果是空的或有!，表示没有密码；\r\n\r\n- **第三字段**：用户组管理者，这个字段也可为空，如果有多个用户组管理者，用,号分隔；\r\n\r\n- **第四字段**：组成员，如果有多个成员，用,号分隔\r\n\r\n> 注意：组管理员可以不是组成员。\r\n\r\n\r\n\r\n# 相关命令\r\n\r\n## 添加用户 - useradd命令\r\n\r\n添加新的用户账号使用useradd命令，其语法如下：\r\n```useradd [选项] 用户名```\r\n其中各选项含义如下：\r\n\r\n|    OPTION    | form  Description                                            |\r\n| :----------: | ------------------------------------------------------------ |\r\n|    -c全称    | 指定一段注释性描述                                           |\r\n|    -d目录    | 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 |\r\n|   -g用户组   | 指定用户所属的私有组，用户组名须为现有存在的名称。<若不指定，则用户私有组名就是该用户名。用-g参数指定用户私有组\r\n有利于对用户进行分组管理。 |\r\n|   -G用户组   | 用户组指定用户所属的附加组。如有多个附加组，则用逗号分开     |\r\n|      -u      | 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 |\r\n|      -p      | 后面直接指定密码                                             |\r\n| -s shell文件 | 指定用户的登录Shell                                          |\r\n\r\n## 修改用户 - usermod命令\r\n\r\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主\r\n目录、用户组、登录Shell等。\r\n\r\n修改已有用户的信息使用usermod命令，其格式如下：\r\n\r\n```usermod [选项] 用户名```\r\n\r\n该命令大部分常用选项与useradd命令基本相同。另有如下新选项：\r\n\r\n- usermod -l 新用户名当前用户名：这个选项指定一个新的账号，即\r\n  将原来的用户名改为新的用户名。\r\n- usermod -L 用户名：锁定用户帐户，使之不能登录系统。\r\n- usermod -U 用户名：对已锁定用户帐户解锁，使之能登录系统\r\n\r\n```\r\n操作举例：\r\n\r\nusermod -l user2 \r\n\r\nuser1usermod -L \r\n\r\nuser1usermod -U user1\r\n另外，其他常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些\r\n选项的意义与useradd命令中的选项一样，可以为用户指定新的属\r\n性值。只不过这里是对已有用户修改其属性。\r\n```\r\n\r\n## 删除用户 - userdel命令\r\n\r\n删除帐号\r\n如果一个用户的账号不再使用，可以从系统中删除。删除用户\r\n账号就是要将/etc/passwd等系统文件中的该用户记录删除，必\r\n要时还删除用户的主目录。删除一个已有的用户账号使用\r\nuserdel命令，其格式如下：\r\n```userdel [选项] 用户名```\r\n常用的选项是-r，它的作用是把用户的主目录一起删除。\r\n例如：\r\n\r\n- userdel –r sam\r\n\r\n此命令删除用户sam在系统文件中（主要是/etc/passwd,\r\n/etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\r\n\r\n## 修改口令 - passwd命令\r\n- 在用useradd创建用户后，下一步就是用passwd来指定其用户口令。\r\n\r\n- 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没\r\n  有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以\r\n  使用，即使是指定空口令。\r\n\r\n- 指定和修改用户口令的Shell命令是passwd。\r\n\r\n- 超级用户可以为自己和其他用户指定口令，普通用户只能用它修改\r\n  自己的口令。命令的格式为：\r\n\r\n  ```passwd [选项] 用户名```\r\n\r\n- passwd可使用的选项：\r\n\r\n  | Option | form  Description                                            |\r\n  | ------ | ------------------------------------------------------------ |\r\n  | -l     | 锁定口令，即禁用账号。使其不能登录                           |\r\n  | -u     | 口令解锁                                                     |\r\n  | -d     | 移去指定用户的口令，使之再登录系统时系统不询问口令，如需恢复该用户登录，要重新设置口令 |\r\n  | -S     | 查看用户账户口令状态                                         |\r\n\r\n  > 以上选项只有root用户可以使用。\r\n\r\n## 修改口令失效 - chage命令\r\n- 命令格式：chage [选项]\\[用户帐户名]\r\n\r\n- 功能描述：用于更改与口令生存期（口令时效）有关的信息。口令时效是系统管理员用来防止机构内不良口令的一种技术。\r\n\r\n- 口令时效意味着过了一段预先设定的时间后（通常是90天），用户会被提示创建一个新口令。\r\n\r\n- 强制用户在一段时间之后更改口令的机制称为口令时效。命令格式\r\n\r\n- chage [<选项>] <用户名>\r\n\r\n- 常用选项：\r\n\r\n  | Option  | form  Description                                            |\r\n  | :-----: | :----------------------------------------------------------- |\r\n  | -d days | 指定自从1970年1月1日起，口令被改变的天数。                   |\r\n  | -m days | 口令的最小生存期，指定用户必须改变口令所间隔的最少天数。如果值为0，口令就不会过期。 |\r\n  | -M days | 口令的最大生存期，指定口令有效的最多天数。当该选项指定的天数加上 |\r\n  |   -d    | 选项指定的天数小于当前的日期，用户在使用该账号前就必须改变口令。 |\r\n  | -I days | 指定口令过期后，账号被锁前不活跃的天数。如果值为0，账号在口令过期后就不会被锁。 |\r\n  | -E date | 指定账号被锁（过期）的日期，日期格式为YYYY-MM-DD。若不用日期，也可以使用自1970年1月1日后经过的天数。 |\r\n  | -W days | 指定口令过期前要警告用户的天数。                             |\r\n  |   -l    | 列出指定用户当前的口令时效信息，以确定账号何时过期。只有该选项可供普通用户使用。 |\r\n\r\n> chage操作举例：\r\n> 用户user1两天内不能更改口令，并且口令最长的存活期\r\n> 为30天， 并在口令过期前5天通知user1。\r\n>\r\n> chage -m 2 -M 30 -W 5 user1\r\n>\r\n> 查看用户user1当前的口令时效信息。\r\n>\r\n> chage -l user1\r\n>\r\n> （passwd –S也可以查看用户口令信息）\r\n> 规定用户第一次登录时需修改密码。\r\n>\r\n> chage –d 0 user1\r\n>\r\n> 注意：上面涉及到的日期采用YYYY-MM-DD格式，但是\r\n> 实际系统中是用自1970年1月1日后经过的天数来表示这个\r\n> 日期，并将设置结果保存在/etc/shadow文件中。\r\n\r\n## 修改用户信息工具 - chfn命令\r\n\r\nchfn 这个工具主要是用来改用户的全名，办公室地址，电话之类的。\r\n\r\n最简单的格式是：chfn 用户名\r\n\r\n复杂的格式如下：chfn \\[ -f full-name ]\\[ -o office ]\\[ -p office-phone ]\\[ -h home-phone ]\\[ -u ]\\[ -v ]\\[ username ]\r\n\r\n\r\n\r\n## 更改文件所属用户 - chown命令\r\n\r\n格式：\r\n```\r\nchown [-c|--changes] [-v|--verbose] [-f|--silent|--quiet] [--dereference][-h|--no-dereference]\r\n [--preserve-root][--from=currentowner:currentgroup] [--no-preserve-root][-R|--recursive]\r\n [--preserve-root] [-H] [-L] [-P]{new-owner|--reference=ref-file} file ...\r\n```\r\n\r\n\r\n\r\n- ```[user[:group]]```指定了新的ownership ，用五种指定方式：\r\n\r\n  | *new-owner* form | Description                                |\r\n  | :--------------: | ------------------------------------------ |\r\n  |       user       | 拥有此文件主权限的新用户名所属用户组未改变 |\r\n  | *user***:**group | 新的用户名和用户组                         |\r\n  |    **:**group    | 指定新的组名                               |\r\n  |   *user***:**    | 新用户名，所属组也改为和其相同             |\r\n  |        :         | 无改动                                     |\r\n\r\n- 选项\r\n\r\n  | OPTION                                     | Description                                                  |\r\n  | :------------------------------------------:|------------------------------------------------------------|\r\n  | **-c**,<br/>**--changes**                  | Similar to --verbose mode, but only displays information about files that are actually changed. For example:<br/>changed ownership of \'dir/dir1/file1\' from hope:neil to hope:hope |\r\n  | **-v**,<br/>**--verbose**                  | changed ownership of \'dir/dir1/file1\' from hope:neil to hope:hope<br/>changed ownership of \'dir/dir1/file1\' from hope:neil to hope:hope ownership of \'dir/dir1\' retained as hope:hope |\r\n  | **-f**,<br/>**--silent**,**--quiet**       | Quiet mode. Do not display output.                           |\r\n  | **--dereference**                          | [Dereference](https://www.computerhope.com/jargon/d/dereference-operator.htm) all [symbolic links](https://www.computerhope.com/jargon/s/symblink.htm). If *file* is a symlink, change the owner of the referenced file, not the symlink itself. This is the default behavior. |\r\n  | **-h**,<br/>**--no-dereference**           | Never dereference symbolic links. If *file* is a symlink, change the owner of the symlink rather than the referenced file. |\r\n  | **--from=**currentowner***:***currentgroup | Change the owner or group of each file only if its current owner or group match *currentowner* and/or *currentgroup*. Either may be omitted, in which case a match is not required for the other attribute. |\r\n  | **--no-preserve-root**                     | Do not treat **/** (the root directory) in any special way. This is the default behavior. If the **--preserve-root** option is previously specified in the command, this option will cancel it. |\r\n  | **--reference=ref-file**                   | Use the owner and group of file *ref-file*, rather than specifying ownership with *new-owner*. |\r\n  | **-R**,<br/>**--recursive**                | Operate on files and directories [recursively](https://www.computerhope.com/jargon/r/recursive.htm). Enter each matching directory, and operate on all its contents.**** |\r\n\r\n  > 来自  https://www.computerhope.com/unix/uchown.htm\r\n\r\n## 添加用户组命令－groupadd命令\r\n\r\n格式：\r\n\r\n```groupadd [<参数>] <组账号名>```\r\n\r\n常用选项：\r\n\r\n-r <系统组账号名> ：用于创建系统组账号（该帐号对应的GID小于500 ）\r\n\r\n-g 后接GID值：用于指定GID （GID必须唯一且大于500 ）\r\n\r\n\r\n\r\n## 修改用户组的属性—groupmod命令\r\n\r\n- 命令格式：# groupmod [<参数>] <组账号名>\r\n\r\n- 常用选项：\r\n  - -g：改变组账号的GID ，组账号名保持不变。\r\n  -  -n：改变组账号名。但组帐号名不变。\r\n\r\n## 管理用户组中的用户—gpasswd命令\r\n\r\n- 命令格式：# gpasswd [<参数>] <组账号名>\r\n\r\n- 常用选项：\r\n\r\n  - -a 用户帐号：将指定用户添加到指定的用户组（组管理员有权执行）\r\n\r\n  - -A 组管理员用户帐号列表：将指定用户设置为用户组的管理员\r\n\r\n  - -d 用户帐号：将指定用户从指定的用户组中删除（组管理员有权执行）\r\n\r\n- 操作举例：\r\n\r\n  - ```gpasswd –a user1 group1gpasswd –A user2 group1```\r\n  - ```gpasswd –A ‘’ group1   //取消group1的管理员```\r\n  - ```gpasswd –d user1 group1```\r\n\r\n  > 将一个用户user1加入一个组usergroup的两种方法？\r\n  >\r\n  > gpasswd –a user1 usergroup （一般由组管理员）\r\n  >\r\n  > usermod –G usergroup user1 （一般由root）\r\n\r\n## 删除用户组—groupdel 命令\r\n\r\n命令格式：\r\n\r\n``` groupdel <组账号名>```\r\n\r\n- 注意事项：\r\n  - 被删除的组账号必须存在\r\n  - 当有用户使用组账号作为私有组并且该用户还存在时，不能删除。\r\n  - 如果用户组中的用户在线，也不能删除。\r\n  - 通常，应当将组中用户移出后再将它删除。\r\n  - 与用户名同名的私有组账号在使用userdel命令删除用户时被同时删除。操作举例：# groupdel mygroup\r\n\r\n## 将用户从当前组转换到指定组命令 - newgrp\r\n\r\n格式：\r\n\r\n```# newgrp <组账号名> ```\r\n\r\n注意事项：\r\n\r\n- 这条命令将当前用户切换到指定用户组，前提条件是指定用户必须属于该组，即该组确实是该用户的主组或附加组。\r\n\r\n- 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。\r\n\r\n- 切换的目标变为当前组（或称有效组）\r\n\r\n- 有效组影响新建文件的权限操作举例：# newgrp bin\r\n\r\n## 其他用户和组状态命令\r\n\r\n- id :显示用户当前的uid、gid和用户所属的组列表\r\n- whoami: 显示当前用户的名称\r\n- who: 主要用于查看当前在线上的（也就是登录的）所有用户情况。这个命令非常有用。如果用户想和其他用户建立即使通讯，比如使用talk命令，那么首先要确定的就是该用户确实在线上，不然talk进程就无法建立起来。又如，系统管理员希望监视每个登陆的用户此时此刻的所作所为，也要使用who命令。\r\n- w: 主要用于查看当前在线上的所有用户，以及用户当前执行的命令。\r\n- groups 用户名:显示指定用户所属的组，如未指定用户则显示当前用户所属的组。\r\n- su: su /su -/ su zhangshan / su -zhangshan\r\n  其他的用户和组状态命令\r\n');
INSERT INTO `article_content` VALUES (32, '# 用户账户的维护命令\r\n##### 1. 增加用户帐号 useradd\r\n- 在命令行下使用 useradd 命令： useradd  用户名 \r\n- 该命令做了下面几件事：\r\n  1. 在 /etc/passwd 文件中增添了一行记录；\r\n  2. 在 /home 目录下创建新用户的主目录，并将 /etc/skel 目录中的文件拷贝到该目录中去；\r\n  3. 但是使用了该命令后，新建的用户暂时还无法登录，因为还没有为该用户设置口令，需要再用 passwd 命令为其设置口令后，才能登录。\r\n  4. 用户的 UID 和 GID 是 useradd 自动选取的，它是将 /etc/passwd 文件中的 UID 加 1，将 etc/group 文件中的 GID 加 1。\r\n##### 2. 删除用户 userdel\r\n- userdel命令用于删除指定的用户账号。其使用的语法格式为：\r\n	       ```userdel [-r][用户账号]```\r\n- 需要补充说明的是userdel命令可删除用户账号与相关的文件。若不加参数，则仅删除用户账号，而不删除相关文件。\r\n- 下面举例说明该命令的使用方法：\r\n  1. userdel lyd      //删除lyd账号\r\n  2. userdel –r lyd   //删除用户的同时删除其工作主目录\r\n#####3. 用户切换 su\r\n- root用户登录：\r\n 命令提示符为：＃\r\n 主目录为： /root\r\n- 普通用户登录：\r\n命令提示符为： $\r\n主目录为：/home/jiangjian    //假定用户名为jiangjian\r\n- 在以普通用户身份登录后，\r\n使用命令：su -，再输入root用户密码就可以暂时切换到root用户身份。\r\n使用命令： su - zhangsan，就可以切换到zhangsan用户身份\r\n- 或者可以用su root或者su zhangsan切换\r\n\r\n![su root和su -效果上的区别](https://upload-images.jianshu.io/upload_images/9031347-55990e2b11510573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n# 目录操作常用命令\r\n#### 4. 文件显示命令 ls\r\n- 显示指定工作目录中所包含的内容的指令是ls，要说明的是ls命令列出文件的名字，而不是文件的内容。该命令的使用方式如下：\r\n```ls [选项] [文件目录列表]```\r\n- ls命令中的常用选项如下：\r\n\r\n| 条件 | 功能 |\r\n| :--------: | :----: |\r\n|-a|显示所有文件及目录 (ls规定将文件名或目录名中开头为“.”的视为隐藏文件，不会列出) |\r\n|-l|除文件名外，也将文件状态、权限、拥有者、文件大小	等信息详细列出 |\r\n|-A|同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录) |\r\n|-t|根据文件建立时间的先后次序列出 |\r\n|-c|按列输出，纵向排序|\r\n|-x|按列输出，横向排序|\r\n|-X|按扩展名排序显示|\r\n|-R|递归显示下层子目录|\r\n|--help|显示帮助信息|\r\n|--version|显示版本信息|\r\n##### 5. 进入目录 cd\r\n- 功能：切换目录\r\n- 用法：\r\n```\r\n cd /some/dir/\r\n cd ~     //~表示用户主目录，也可以直接写成cd\r\n cd ..     //..表示当前目录的父目录 \r\n cd ../..   //../..表示当前目录的父目录的父目录\r\n cd -   //返回最近所在的目录\r\n```\r\n\r\n##### 6. 显示文本文件内容 cat\r\n- 显示文本文件内容的命令是cat命令，用来将文件的内容显示到终端上，其命令语法如下：\r\n          ```cat  [选项]  文件列表```\r\n- 用法：\r\n  ``` $ cat file```\r\n- 分屏显示：\r\n cat test.txt|more 或 more test.txt\r\n 然后按空格键（按enter键是一行一行往下翻，按b键上翻）\r\n less类似于more，还可以上下翻页\r\n##### 7. 显示文本文件内容 head/tail\r\n- 用法：\r\n```\r\nhead/head -10/head -n 10\r\ntail/tail -7/tail -n 7\r\n```\r\n##### 8. 显示当前所在目录 pwd\r\n- 用法：pwd\r\n#####9. 生成一个新文件或是更改文件的时间 touch\r\n- 用法：\r\n```touch xxx```\r\n\r\n##### 10. 删除文件或目录 rm\r\n-用法：\r\n ```rm /some/dir/file1 \r\n rm -i /some/dir/file1   交互式删除，也就是有警告。\r\n rm -f /some/dir/file1    -f表示不给出提示\r\n rm -r /some/dir/         -r删除目录及目录下的子目录和文件\r\n rm -rf /some/dir/       上两种功能结合\r\n ```\r\n\r\n\r\n##### 11. 复制文件或目录 cp\r\n- Linux下的cp命令用于复制文件或目录，该命令是最重要的文件操作命令，其命令格式如下：\r\n	cp　[选项]　 源文件　目标文件\r\n	 	cp　[选项]　 源文件组 　目标目录\r\n- 功能：复制文件或目录\r\n- 用法：\r\n ```cp file1 file2\r\n cp /some/dir/file1 /someother/dir/\r\n cp /some/dir/file1 file2  /someother/dir/\r\n cp /some/dir/file1 /someother/dir/file2\r\n cp -r /some/dir/ /other/dir/     //-r 表示连目录和目录中的内容一起复制\r\n cp -p /some/dir/ /other/dir/     //-p 表示保留源文件或目录的属性\r\n ```\r\n\r\n#####12. 移动或重命名文件或目录 mv\r\n- 功能：移动文件或目录、文件或目录改名\r\n- 用法：\r\n```\r\n mv /some/dir/file1 /someother/dir/\r\n mv /some/dir/file1 /someother/dir/file2\r\n mv /some/dir/files /someother/dir/\r\n mv -r /some/dir/ /someother/dir/\r\n```\r\n##### 13. mkdir\r\n-功能：创建目录\r\n-用法：\r\n```\r\n mkdir /some/path/dir/\r\nmkdir -p dir1/dir2      //-p表示可以同时建立dir1和dir2  \r\n```\r\n##### 14. rmdir\r\n- 功能：删除空目录\r\n- 用法：\r\n rmdir somedir/\r\n#####15. whereis\r\n- 在命令whereis后面加上文件/目录,即可获得该文件或目录及有关文档的完整路径。\r\n- 用法：\r\n whereis mount; \r\n  whereis man \r\n- 在which后面加上命令名，可以找到与之相关的位于系统路径中的命令、文档的完整路径。\r\n- 用法：\r\n$ which mount\r\n##### 16. wc命令\r\n- 作用：计算目标文件的字节数、字数、行数，并将其打印出来！\r\n- 用法：wc [选项] filename\r\n- 选项：\r\n\r\n|选项名|功能|\r\n|:---:|:---:|\r\n|-c|计算文件字节数|\r\n|-m|计算文件字符数，不能与-c一起用|\r\n|-w|统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串|\r\n|-L |打印最长行的长度。|\r\n\r\n##### 17. usermod命令行\r\n**usermod命令**用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user [id](http://man.linuxde.net/id \"id命令\")，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的[crontab](http://man.linuxde.net/crontab \"crontab命令\")档。也需手动更改使用者的[at](http://man.linuxde.net/at \"at命令\")工作档。采用NIS server须在server上更动相关的NIS设定。\r\n\r\n**语法**\r\n> usermod [选项] <参数>\r\n\r\n**选项**\r\n> -c<备注>：修改用户帐号的备注文字；\r\n-d<登入目录>：修改用户登入时的目录；\r\n-e<有效期限>：修改帐号的有效期限；\r\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\r\n-g<群组>：修改用户所属的群组；\r\n-G<群组>；修改用户所属的附加群组；\r\n-l<帐号名称>：修改用户帐号名称；\r\n-L：锁定用户密码，使密码无效；\r\n-s<shell>：修改用户登入后所使用的shell；\r\n-u<uid>：修改用户ID；\r\n-U:解除密码锁定。\r\n\r\n**参数**\r\n用户名\r\n\r\n**用例**\r\n将newuser2添加到组staff中：\r\n> usermod -G staff newuser2\r\n\r\n修改newuser的用户名为newuser1：\r\n> usermod -l newuser1 newuser\r\n\r\n锁定账号newuser1：\r\n>usermod -L newuser1\r\n\r\n解除对newuser1的锁定：\r\n>usermod -U newuser1\r\n\r\n##### 18. 其他（后面继续添加）（用到时再了解）\r\n- echo 功能：在屏幕上打印出指定的字符串。\r\n- grep：\r\nLinux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。（后面遇到详细了解）\r\n');
INSERT INTO `article_content` VALUES (33, '> [mybatis中文文档](http://www.mybatis.org/mybatis-3/zh/getting-started.html)\r\n\r\n# 一、创建数据表和相应的javaBean\r\n```java\r\npublic class Employee {\r\n    private Integer id;\r\n    private String name;\r\n    private char gender;\r\n    private String email;\r\n//省略setter、getter等方法\r\n}\r\n```\r\n```sql\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for `tbl_employee`\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `tbl_employee`;\r\nCREATE TABLE `tbl_employee` (\r\n  `id` varchar(11) NOT NULL,\r\n  `name` varchar(20) NOT NULL DEFAULT \'\',\r\n  `gender` char(1) NOT NULL DEFAULT \'\',\r\n  `email` varchar(100) DEFAULT \'\',\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\n-- ----------------------------\r\n-- Records of tbl_employee\r\n-- ----------------------------\r\nINSERT INTO `tbl_employee` VALUES (\'0164551\', \'heshaowen\', \'M\', \'95934@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0164552\', \'Flip\', \'M\', \'012346@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0164557\', \'mark\', \'M\', \'01647@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0164558\', \'Alice\', \'W\', \'0164558@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0164559\', \'jack\', \'M\', \'9859@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0164560\', \'mark\', \'M\', \'017@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0174551\', \'he\', \'M\', \'951@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0174552\', \'LiHua\', \'W\', \'0123456@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0174558\', \'j\', \'W\', \'016@qq.com\');\r\nINSERT INTO `tbl_employee` VALUES (\'0174560\', \'ll\', \'M\', \'01647@qq.com\');\r\n```\r\n\r\n# 二、导入相关依赖\r\n```\r\n        <!--mybatis-->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.4.6</version>\r\n        </dependency>\r\n\r\n        <!-- mysql-connector-java -->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>8.0.12</version>\r\n        </dependency>\r\n\r\n        <!-- log4j -->\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-core</artifactId>\r\n            <version>2.11.1</version>\r\n        </dependency>\r\n```\r\n# 三、创建SqlSessionFactory的配置文件mybatis-config.xml\r\n此文件的约束头不可或缺，我们可以先从官方文档中先复制一份下来,增加自己数据库的配置：\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"${driver}\"/>\r\n        <property name=\"url\" value=\"${url}\"/>\r\n        <property name=\"username\" value=\"${username}\"/>\r\n        <property name=\"password\" value=\"${password}\"/>\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\r\n  </mappers>\r\n</configuration>\r\n```\r\n> 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。\r\n\r\n> 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。\r\n\r\n> XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨。\r\n\r\n> 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。\r\n-----  来自文档\r\n# 三、创建mapper文件\r\n\r\n\r\n');
INSERT INTO `article_content` VALUES (34, '# 基本概念\r\n32位的CPU与64位CPU\r\n>以下内容摘自维基百科：\r\n64 位 CPU 是指 CPU 内部的通用寄存器的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算。那么 32 位 CPU 同理。\r\n一个 CPU，联系外部的数据总线与地址总线，可能有不同的宽度；术语“64位”也常用于描述这些总线的大小。不过这一术语也可能指电脑指令集的指令长度，或其它的数据项。去掉进一步的条件，“64位”电脑架构一般具有 64 位宽的整数型寄存器，它可支持 64 位“区块”的整数型数据。\r\n64 位架构无疑可应用在需要处理大量数据的应用程序，如数字视频、科学运算、和早期的大型数据库。\r\n\r\n# 那么 32 位 CPU 与 64 位 CPU 到底有什么区别？\r\n\r\n**数据处理能力增强**：64 位 CPU 通用寄存器的位宽增加一倍，这也就意味着 64 位 CPU 可以一次性处理 64bit 的整形数据；\r\n**内存寻址能力增强**：如果是 32 位 CPU 的话，它的地址总线最多不会超过 32，那么它所能达到的寻址范围也就不会超过 2 的 32 次方字节（存储单元以字节为单位），也就是 4GB，而如果是 64 位处理器的话，它所能达到的寻址范围理论上就会是 2 的 64 次方字节（上亿 GB）。\r\n> 补充：一般处理器多少位是指通用寄存器的长度，当然数据线需要与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。\r\n\r\n# 32位操作系统与64位操作系统\r\n平时我们所说的 32 位操作系统也被称为 X86 系统，x64 代表 64 位操作系统，关于它的简略解释：[为什么32位的计算机系统不叫x32而叫x86呢？](https://www.zhihu.com/question/49601232/answer/309709569)\r\n\r\n### 关于 32 位操作系统与 64 位操作系统的区别如下：\r\n\r\n**32 位操作系统**既可以运行在 32 位的 CPU 上，也可以运行在 64 位的 CPU 上，只不过，运行在 64 位 CPU 上的话，就有点“大马拉小车”的感觉了——无法发挥出 CPU 的全部能力。\r\n\r\n**64 位操作系统**只能运行在 64 位的 CPU 上，因此如果一个操作系统是 64 位，那么它的 CPU 架构也必定是 64 位。\r\n\r\n**64 位操作系统**相比于 32 位操作系统的优势正如上述 64 位 CPU 与 32 位 CPU 的优势一样。\r\n\r\n# 总线结构与主板构成\r\n\r\n>注：以下两部分内容摘抄自：[32位系统最大只能支持4GB内存之由来~](https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html)\r\n\r\n**在解决本文标题所述的问题之前，我们再来了解一些关于总线结构与主板构成的相关知识。**\r\n\r\n说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。\r\n\r\n在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。\r\n\r\n所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。\r\n\r\n在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。\r\n\r\n随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算机采用的结构：\r\n\r\n![](https://upload-images.jianshu.io/upload_images/9031347-ab4d7e016a79f0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I/O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。\r\n\r\n在上副图中，我没有画出数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。\r\n\r\n**下面来说一下几个主要总线和南北桥的作用：**\r\n\r\n**FSB总线**：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说，FSB总线的频率直接影响到CPU访问内存的速度。\r\n\r\n**北桥**：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。\r\n\r\n**PCI总线**：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。\r\n\r\n**南桥**：主要负责I/O设备之间的通信，CPU要想访问外设必须经过南桥芯片。\r\n\r\n#####在了解了这些基础东西之后，下面来讲解一下为何 32 位系统最大只支持 4GB 内存。（是的，就算是 64 位的 CPU，装载 32 位的操作系统，它的寻址能力还是 4GB。）\r\n\r\n对于标题的解释\r\n在使用计算机时，其最大支持的内存是由操作系统和硬件两方面决定的。\r\n\r\n#### 先说一下硬件方面的因素\r\n在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232=4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。\r\n\r\n用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。\r\n\r\n#### 对于32位的windows操作系统\r\n其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：\r\n\r\n![](https://upload-images.jianshu.io/upload_images/9031347-a4daf067f41723a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。\r\n\r\n#### 于64位的操作系统\r\n其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。\r\n\r\n#### 总结\r\n对于以上所述，我进行一下简单的总结：\r\n\r\n一个计算机，它的内存访问能力是由硬件和软件共同决定的。硬件层面就指 CPU 的寻址能力，也就是地址总线的个数。软件层面，指的就是操作系统。实际上我们（进程）在进行内存访问的时候，访问的都是逻辑地址，而逻辑地址是由操作系统提供的。对于 32 位的操作系统，其逻辑地址编码采用的地址位数是 32 位，那么操作系统所提供的逻辑地址寻址范围就是 4GB。从这个方面来说，纵使你的 CPU 实际寻址能力为 2 的 64 次方，由于操作系统只提供 4GB 的逻辑地址，那 CPU 透过操作系统所能访问到的内存大小也就只有4GB了。\r\n\r\n对与上述总结，我还有一个简单的补充：\r\n\r\n> 在和我的大神小伙伴讨论的时候，他对于“为什么 64 位 CPU 装载 32 位操作系统，它的寻址能力还是 4GB”这个问题的解答，只说了一句话：“32 位操作系统没有对应 64 位的寻址指令”。在细细品味之后，觉得颇有道理，我对于这句话的浅显理解是：32 位操作系统没有对应 64 位的寻址指令，所以它不能提供 4GB 以上的逻辑地址，所以 64 位 CPU 透过 32 位操作系统，它的寻址能力依旧是 4GB。\r\n\r\n参考阅读\r\n维基百科：[64位](https://zh.wikipedia.org/wiki/64%E4%BD%8D%E5%85%83)\r\n[32位系统最大只能支持4GB内存之由来](https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html)\r\n--------------------- \r\n作者：珩翊 \r\n来源：CSDN \r\n原文：https://blog.csdn.net/championhengyi/article/details/80458060 \r\n版权声明：本文为博主原创文章，转载请附上博文链接！\r\n');
INSERT INTO `article_content` VALUES (35, '> 很久以前就开始看设计模式了，后面停了一段时间然后借到了一本《Head First 设计模式》，head first即面向初学者之意，语言风趣，例子简单，讲解设计模式循序渐进，许多规范会通过很多现实中的例子来讲解其意义所在！虽有些长篇大论，但是能在浅显的语言中收获以往其他设计模式书籍不能给的知识，如获至宝，手不释卷，让我重燃学会设计模式的兴趣！废话少说，赶紧写下看到的第一个设计模式吧！\r\n\r\n# 策略模式\r\n哎，为什么写起来感觉捉襟见肘，书中例子是很简单，但即使是大致的写下来就很浪费时间了，这种东西还是要在日常代码时间中将其用到融会贯通，成为自己的东西，而不是现在看一遍或者看个两遍就依葫芦画瓢写下来，甚至发布出去给别人看。。。\r\n\r\n细细一想还是日后23中设计模式和6大原则成竹于胸时，再将其转化为文字吧。\r\n要记住，你的博客是给自己看的，不是为了迎合别人的！');

-- ----------------------------
-- Table structure for collection
-- ----------------------------
DROP TABLE IF EXISTS `collection`;
CREATE TABLE `collection`  (
  `user_no` int(10) UNSIGNED NOT NULL COMMENT '收藏用户',
  `article_no` int(10) UNSIGNED NOT NULL COMMENT '收藏文章',
  PRIMARY KEY (`user_no`, `article_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_no` int(11) NOT NULL COMMENT '评论序号',
  `comment_content` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '内容，无论这里设为多长，前台都要限制字数！',
  `like_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '评论点赞数',
  `user_no` int(10) UNSIGNED NOT NULL COMMENT '所属用户序号',
  `article_no` int(10) UNSIGNED NOT NULL COMMENT '这个可建立索引，因为通过文章no查找评论的操作很多！',
  `comment_time` timestamp(0) NOT NULL COMMENT '评论时间，类型时间戳，默认当前时区的时间，前台是用框架显示相对时间',
  `reply_comment_no` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '不为0表示此评论是回复某个评论的，为0表示直接评论某文章',
  `comment_level` int(10) UNSIGNED NOT NULL COMMENT '表示在文章中的评论楼层',
  PRIMARY KEY (`comment_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for corpus
-- ----------------------------
DROP TABLE IF EXISTS `corpus`;
CREATE TABLE `corpus`  (
  `corpus_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '文集名字，需去重',
  `user_no` int(10) UNSIGNED NOT NULL COMMENT '所属用户id',
  `blog_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '文集文章数',
  PRIMARY KEY (`corpus_name`, `user_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of corpus
-- ----------------------------
INSERT INTO `corpus` VALUES ('ACM', 1, 2);
INSERT INTO `corpus` VALUES ('Spring', 121, 3);
INSERT INTO `corpus` VALUES ('docker', 1, 1);
INSERT INTO `corpus` VALUES ('j2ee', 1, 2);
INSERT INTO `corpus` VALUES ('java', 1, 4);
INSERT INTO `corpus` VALUES ('java', 121, 10);
INSERT INTO `corpus` VALUES ('linux', 1, 4);
INSERT INTO `corpus` VALUES ('mybatis', 1, 1);
INSERT INTO `corpus` VALUES ('一些错误', 121, 3);
INSERT INTO `corpus` VALUES ('乱想', 121, 2);
INSERT INTO `corpus` VALUES ('操作系统', 1, 3);
INSERT INTO `corpus` VALUES ('数据库', 121, 2);
INSERT INTO `corpus` VALUES ('设计模式', 1, 1);

-- ----------------------------
-- Table structure for follow
-- ----------------------------
DROP TABLE IF EXISTS `follow`;
CREATE TABLE `follow`  (
  `followed_user_no` int(10) UNSIGNED NOT NULL COMMENT '表示被关注的人',
  `follower_user_no` int(10) UNSIGNED NOT NULL COMMENT '关注者，粉丝序号',
  PRIMARY KEY (`followed_user_no`, `follower_user_no`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of follow
-- ----------------------------
INSERT INTO `follow` VALUES (103, 1);
INSERT INTO `follow` VALUES (121, 1);
INSERT INTO `follow` VALUES (125, 1);
INSERT INTO `follow` VALUES (125, 103);
INSERT INTO `follow` VALUES (125, 121);
INSERT INTO `follow` VALUES (125, 127);
INSERT INTO `follow` VALUES (127, 1);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `user_no` int(15) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户的序号，从0开始，自增',
  `username` varchar(50) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '用户名，标识用户和登录',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '有效邮箱号，需验证，可用来登录，需要去重',
  `tel` varchar(20) CHARACTER SET ascii COLLATE ascii_bin NOT NULL DEFAULT '' COMMENT '有效电话，需验证，可用来登录，需要去重',
  `password` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_bin NOT NULL DEFAULT '' COMMENT '由电话为盐值加密的密码，为ascII码可见字符。',
  `avatar` varchar(255) CHARACTER SET armscii8 COLLATE armscii8_bin NOT NULL DEFAULT '' COMMENT '头像图片链接。默认值为服务器中的一张图片的资源定位符',
  `self_summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '个人简介，默认是空字符串，前台检测到是空就直接显示默认值',
  `gender` bit(2) NOT NULL DEFAULT b'10' COMMENT '性别0W,1M，2保密',
  `follow_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '关注博主数',
  `follower_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '粉丝数',
  `blog_num_private` int(8) UNSIGNED NOT NULL DEFAULT 0 COMMENT '私密博客数',
  `blog_num_public` int(8) UNSIGNED NOT NULL DEFAULT 0 COMMENT '公开博客数',
  `word_num` bigint(20) UNSIGNED NOT NULL DEFAULT 0 COMMENT '所有博客总字数',
  `like_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '获取喜欢数',
  `github` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '个人github网址',
  `wechat_qr_img_link` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT '微信二维码图片地址',
  PRIMARY KEY (`user_no`) USING BTREE,
  UNIQUE INDEX `uniq_username`(`username`) USING BTREE,
  UNIQUE INDEX `uniq_email`(`email`) USING BTREE,
  UNIQUE INDEX `uniq_tel`(`tel`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 128 CHARACTER SET = utf8 COLLATE = utf8_bin COMMENT = '账号信息表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '不过意局', '985934131@qq.com', '19876543211', 'aTIFiYAGDyyRMLWf1TsGOw==', '../front_end/img/hajiwon_lovely.png', '金风玉露一相逢，便胜却人间无数。', b'01', 0, 0, 0, 0, 0, 0, 'www.github.com/hswbug', 'wechat23333.png');
INSERT INTO `user` VALUES (103, 'user', '2127804711@qq.com', '18779340049', 'KYuYKcNbCBagq+AtDBF7Wg==', '456789', '456456456', b'10', 0, 0, 0, 0, 0, 0, '', '');
INSERT INTO `user` VALUES (121, 'hajiwon', '', '12345678900', 'Bohb6IOr/MPgGNOCNp1cXg==', '../front_end/img/hajiwon_any.png', '琵琶弦上说相思，当时明月在，曾照彩云归！', b'01', 0, 0, 0, 0, 0, 0, 'https://www.github.com/hesw', 'wechat.png');
INSERT INTO `user` VALUES (125, 'user1', '1111111@qq,com', '1821111111', '123123123', '123456788', '', b'10', 0, 0, 0, 0, 0, 0, '', '');
INSERT INTO `user` VALUES (127, '123123', '123456789@qq.com', '', 'S4rjznXYtp4Nqq70GBGtGA==', '9.png', '', b'10', 0, 0, 0, 0, 0, 0, '', '');

SET FOREIGN_KEY_CHECKS = 1;
